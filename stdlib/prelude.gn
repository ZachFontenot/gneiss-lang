-- Gneiss Prelude
-- Auto-imported into every program

-- Core sum types
type Option a = | Some a | None
type Result e a = | Ok a | Err e

-- I/O Error type
type IoError =
    | NotFound
    | PermissionDenied
    | ConnectionRefused
    | ConnectionReset
    | BrokenPipe
    | TimedOut
    | AddrInUse
    | AddrNotAvailable
    | InvalidInput String
    | IoOther String

-- Identity combinator
let id x = x

-- Constant combinator (returns first argument, ignores second)
let const x _ = x

-- Flip argument order
let flip f x y = f y x

-- List operations
let rec map f xs =
    match xs with
    | [] -> []
    | x :: rest -> f x :: map f rest
    end

let rec filter p xs =
    match xs with
    | [] -> []
    | x :: rest -> if p x then x :: filter p rest else filter p rest
    end

let rec foldl f acc xs =
    match xs with
    | [] -> acc
    | x :: rest -> foldl f (f acc x) rest
    end

let rec foldr f acc xs =
    match xs with
    | [] -> acc
    | x :: rest -> f x (foldr f acc rest)
    end

let null xs = match xs with | [] -> true | _ -> false end
let rec length xs = match xs with | [] -> 0 | _ :: rest -> 1 + length rest end
let rec reverse xs = foldl (fun acc x -> x :: acc) [] xs
let head xs = match xs with | [] -> None | x :: _ -> Some x end
let tail xs = match xs with | [] -> None | _ :: rest -> Some rest end

let rec drop_while p xs =
    match xs with
    | [] -> []
    | x :: rest -> if p x then drop_while p rest else xs
    end

-- Range generation
-- range start end generates [start, start+1, ..., end-1] (exclusive end)
let rec range_helper start end_ acc =
    if start >= end_ then reverse acc
    else range_helper (start + 1) end_ (start :: acc)

let range start end_ = range_helper start end_ []

-- range_inclusive start end generates [start, start+1, ..., end] (inclusive end)
let range_inclusive start end_ = range start (end_ + 1)

-- String operations
-- Note: string_to_lower, string_to_upper, string_trim, string_split, string_join
-- are now native builtins for performance

let string_contains needle haystack =
    match string_index_of needle haystack with
    | Some _ -> true
    | None -> false
    end

let string_starts_with prefix s =
    string_substring 0 (string_length prefix) s == prefix

let string_ends_with suffix s =
    let slen = string_length s in
    let suflen = string_length suffix in
    if suflen > slen then false
    else string_substring (slen - suflen) slen s == suffix

let string_replace from to s = string_join to (string_split from s)
