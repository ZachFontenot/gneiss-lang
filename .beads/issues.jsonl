{"id":"gneiss-lang-0e9","title":"Add generalization level tracking property tests","description":"Add property-based tests verifying that type variable levels are tracked correctly for let-polymorphism.\n\n**Property to test:**\nType variables that \"escape\" their scope (are used outside the let body where they were introduced) should NOT be generalized.\n\n**Example of what should fail:**\n```\nfun x -\u003e let y = x in y  -- x escapes, should not be generalized\n```\n\n**Requires:**\n- Generator for let expressions with escaping variables\n- Way to inspect whether a type variable was generalized","acceptance_criteria":"- Property test: escaping type variables are not generalized\n- Property test: non-escaping type variables at appropriate level are generalized","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-09T10:44:10.15267-05:00","updated_at":"2025-12-09T10:44:10.15267-05:00","labels":["proptest","testing","type-system"],"dependencies":[{"issue_id":"gneiss-lang-0e9","depends_on_id":"gneiss-lang-d4s","type":"blocks","created_at":"2025-12-09T10:44:10.153766-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-3ik","title":"Add pattern matching exhaustiveness property tests","description":"Add property-based tests for pattern matching exhaustiveness checking.\n\n**Property to test:**\nIf the type checker marks a match expression as exhaustive, evaluation should never fall through (no `MatchFailed` error at runtime).\n\n**Requires:**\n- Generator for ADT definitions\n- Generator for pattern sets covering an ADT\n- Integration with exhaustiveness checker","acceptance_criteria":"- Property test: exhaustive patterns never fail at runtime\n- Property test: non-exhaustive patterns are rejected by type checker","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-09T10:44:09.522184-05:00","updated_at":"2025-12-09T10:44:09.522184-05:00","labels":["pattern-matching","proptest","testing"],"dependencies":[{"issue_id":"gneiss-lang-3ik","depends_on_id":"gneiss-lang-d4s","type":"blocks","created_at":"2025-12-09T10:44:09.523459-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-3xz","title":"Implement yield points at send/recv","description":"Wire up Channel.send and Channel.recv to actually block the process.\n\n- send blocks until a receiver is ready (rendezvous semantics)\n- recv blocks until a sender is ready\n- Process state transitions: Ready → BlockedSend/BlockedRecv → Ready → Done\n\nThe runtime already has the blocking logic (runtime.rs), but eval.rs doesn't use it correctly. After CPS transform, these ops should capture continuation and return to scheduler instead of continuing execution.\n\nCritical files: src/eval.rs, src/runtime.rs","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-08T19:32:50.977902-05:00","updated_at":"2025-12-08T22:42:34.710486-05:00","closed_at":"2025-12-08T22:42:34.710486-05:00","dependencies":[{"issue_id":"gneiss-lang-3xz","depends_on_id":"gneiss-lang-94p","type":"parent-child","created_at":"2025-12-08T19:32:50.978628-05:00","created_by":"daemon"},{"issue_id":"gneiss-lang-3xz","depends_on_id":"gneiss-lang-q2d","type":"blocks","created_at":"2025-12-08T19:32:50.979246-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-4ya","title":"Add unification idempotence property test","description":"Add property test for unification idempotence: if `unify(a, b)` succeeds, calling `unify(a, b)` again should also succeed and produce the same result.\n\nCurrently we test symmetry and reflexivity but not idempotence. This is important for detecting bugs in the union-find linking.","acceptance_criteria":"- Property test: `unify(a,b); unify(a,b)` succeeds if first unify succeeds\n- After double unification, `a.resolve() == b.resolve()`","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-09T10:44:10.491717-05:00","updated_at":"2025-12-09T10:44:10.491717-05:00","labels":["proptest","testing","type-system"],"dependencies":[{"issue_id":"gneiss-lang-4ya","depends_on_id":"gneiss-lang-d4s","type":"blocks","created_at":"2025-12-09T10:44:10.49267-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-6ci","title":"Local let expressions don't support function syntax or recursion","description":"Local let expressions have two limitations compared to top-level declarations:\n\n1. **No function syntax**: `let f x = ... in body` doesn't parse (only `let x = ... in body` works)\n2. **No recursion**: Even with `let f = fun x -\u003e ... f ... in body`, `f` is not in scope in the RHS\n\nTop-level declarations support both:\n```gneiss\nlet map f lst =       -- function syntax works\n  match lst with\n  | [] -\u003e []\n  | hd :: rest -\u003e f hd :: map f rest  -- recursion works\n```\n\nLocal let should work the same way:\n```gneiss\nlet main () =\n    let loop n = if n == 0 then 0 else n + loop (n - 1) in\n    print (loop 10)\n```\n\nOptions:\n1. Make all local `let` implicitly recursive (like OCaml's `let rec` but without requiring the keyword)\n2. Add `let rec` syntax for explicit recursion\n3. Just support function syntax and make it recursive (current top-level behavior)","notes":"## Implementation Complete\n\n### Changes Made\n\n1. **Parser** (`src/parser.rs:325-375`)\n   - Modified `parse_expr_let` to support function syntax: `let f x y = expr in body`\n   - Desugars to `let f = fun x y -\u003e expr in body`\n   - Collects parameters after the name pattern until `=` is reached\n\n2. **Type Inference** (`src/infer.rs:311-370`)\n   - When pattern is `Var(name)` and value is `Lambda`, adds name to env with preliminary type before inferring lambda\n   - Unifies preliminary type with inferred type for proper recursive type inference\n\n3. **Evaluator** (`src/eval.rs:660-691`)\n   - When binding a variable to a closure, creates recursive closure\n   - New environment includes the binding to itself, enabling self-reference\n\n### Tests Added\n- 6 new tests for local recursive functions:\n  - `test_local_recursive_function` - basic sum recursion\n  - `test_local_recursive_function_factorial` - factorial\n  - `test_local_recursive_function_lambda_form` - explicit lambda form\n  - `test_local_function_non_recursive` - non-recursive still works\n  - `test_local_function_multiple_params` - multiple parameters\n  - `test_nested_local_functions` - nested local functions\n\n### Now Works\n```gneiss\nlet main () =\n    let fact n = if n == 0 then 1 else n * fact (n - 1) in\n    print (fact 5)  -- prints 120\n```","status":"closed","priority":2,"issue_type":"feature","assignee":"claude","created_at":"2025-12-09T13:11:36.516354-05:00","updated_at":"2025-12-09T13:55:23.30422-05:00","closed_at":"2025-12-09T13:55:23.30422-05:00","labels":["parser","syntax"]}
{"id":"gneiss-lang-6gf","title":"Implement proper union-find for type variable unification","description":"The current type variable linking in `types.rs` uses a naive approach that can degrade to O(n) per lookup. We need proper union-find with:\n\n1. **Path compression** in `resolve()` — update intermediate links to point directly to the root\n2. **Union-by-rank** (or union-by-size) — attach smaller trees under larger ones\n\nCurrent code just does:\n```rust\n*var.borrow_mut() = TypeVar::Link(other.clone());\n```\n\nThis can create long chains like: `a -\u003e b -\u003e c -\u003e d -\u003e Int`\n\nWith path compression, after resolving `a`, we'd have: `a -\u003e Int, b -\u003e Int, c -\u003e Int, d -\u003e Int`","design":"## Implementation\n\n### Option A: Path compression only (simpler)\nModify `resolve()` to update links as it traverses:\n\n```rust\npub fn resolve(\u0026self) -\u003e Type {\n    match self {\n        Type::Var(var) =\u003e {\n            let inner = var.borrow().clone();\n            match inner {\n                TypeVar::Link(ty) =\u003e {\n                    let resolved = ty.resolve();\n                    // Path compression: point directly to root\n                    *var.borrow_mut() = TypeVar::Link(resolved.clone());\n                    resolved\n                }\n                _ =\u003e self.clone(),\n            }\n        }\n        _ =\u003e self.clone(),\n    }\n}\n```\n\n### Option B: Full union-find with rank\nAdd rank to `TypeVar::Unbound`:\n```rust\nTypeVar::Unbound { id: TypeVarId, level: u32, rank: u32 }\n```\n\nIn unification, compare ranks and link lower to higher.\n\n### Recommendation\nStart with Option A (path compression only). It's simpler and provides most of the benefit. Union-by-rank matters less when we're unifying type variables with concrete types (which have no rank).\n\n### Considerations\n- Path compression mutates during `resolve()`, which is conceptually a \"read\" operation — this is the standard union-find trade-off\n- Must ensure this doesn't interfere with level tracking for let-polymorphism\n- The `Clone` on `Type` with `Rc\u003cRefCell\u003c...\u003e\u003e` means clones share the same underlying cell, which is correct for union-find","acceptance_criteria":"1. `resolve()` implements path compression\n2. Unification chains are O(α(n)) amortized, not O(n)\n3. All existing tests pass\n4. Level tracking for let-polymorphism still works correctly","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-09T10:34:15.751725-05:00","updated_at":"2025-12-09T10:34:15.751725-05:00","labels":["performance","type-system"]}
{"id":"gneiss-lang-709","title":"Constructor application type checking fails","description":"Constructors with fields fail type checking when applied as functions.\n\nExample that fails:\n```gneiss\ntype Option a = Some a | None\nlet x = Some 5  -- Error: expected Option t3, found ()\n```\n\nRoot cause: `Some 5` parses as `Apply(Constructor{name:\"Some\", args:[]}, Lit(5))`. The type checker sees `Constructor{args:[]}` and expects the args to be filled in, but they're empty, so it fails with a misleading error.\n\nFix: When a constructor has fields but `args` is empty, type it as a curried function type. So `Some : a -\u003e Option a`, then `Apply(Some, 5)` works via normal function application.","status":"closed","priority":1,"issue_type":"bug","assignee":"claude","created_at":"2025-12-09T14:38:47.979217-05:00","updated_at":"2025-12-09T14:50:57.380231-05:00","closed_at":"2025-12-09T14:50:57.380231-05:00","labels":["bug","type-system"]}
{"id":"gneiss-lang-7gf","title":"Channel type inference doesn't constrain element type","description":"Channels are typed as `Channel 'a` (polymorphic) but the type checker doesn't properly unify the type parameter when send/recv are used. This allows type-unsafe programs to pass type checking.\n\nExample that should be rejected but isn't:\n```gneiss\nlet main () =\n    let ch = Channel.new in\n    let _ = spawn (fun () -\u003e Channel.send ch 42) in\n    let _ = spawn (fun () -\u003e Channel.send ch \"oops\") in  -- should error!\n    let x = Channel.recv ch in\n    x + 1  -- runtime type error if string received\n```\n\nThe type checker infers `main : () -\u003e Int` without catching that both Int and String are sent on the same channel.\n\nExpected behavior: Type error at compile time when sending incompatible types on the same channel.\n\nRoot cause: Likely the inference rules for Channel.send and Channel.recv don't properly constrain the channel's type parameter to be consistent across all uses.","design":"Implement ML-style value restriction: only generalize let-bindings where the RHS is a syntactic value (lambda, literal, variable, constructor). Applications like `Channel.new` won't be generalized, so the channel's type variable stays shared across all uses and gets refined/constrained properly.","status":"closed","priority":1,"issue_type":"bug","assignee":"claude","created_at":"2025-12-09T00:12:39.137796-05:00","updated_at":"2025-12-09T00:26:20.278844-05:00","closed_at":"2025-12-09T00:26:20.278844-05:00","labels":["soundness","type-system"]}
{"id":"gneiss-lang-94p","title":"Phase 1: Implement some of the Concurrency Story","description":"Complete Phase 1 of the Gneiss roadmap: get two processes communicating over a channel end-to-end.\n\nGoal: ML-style types + Go-style channels working together.\n\nKey deliverable: Can write and run concurrent Gneiss programs with channels.","status":"open","priority":1,"issue_type":"epic","created_at":"2025-12-08T19:32:38.715275-05:00","updated_at":"2025-12-08T19:32:38.715275-05:00"}
{"id":"gneiss-lang-bpl","title":"Implement delimited continuations (reset/shift)","description":"Implement delimited continuations following docs/delim_cont.md specification.\n\nThis involves changes to:\n1. Lexer - add Reset and Shift tokens\n2. AST - add Reset and Shift variants to ExprKind\n3. Parser - parse reset/shift expressions\n4. Type inference - type reset and shift\n5. Evaluator - implement Prompt frame, Continuation value, and continuation capture/application\n\nSee docs/delim_cont.md for full specification.","notes":"## Implementation Complete\n\n### Changes Made\n\n1. **Lexer** (`src/lexer.rs`)\n   - Added `Reset` and `Shift` tokens\n   - Added keyword recognition for `reset` and `shift`\n\n2. **AST** (`src/ast.rs`)\n   - Added `ExprKind::Reset(Rc\u003cExpr\u003e)` variant\n   - Added `ExprKind::Shift { param: Pattern, body: Rc\u003cExpr\u003e }` variant\n\n3. **Parser** (`src/parser.rs`)\n   - Added `Reset` and `Shift` to `is_atom_start`\n   - Added parsing for `reset expr` and `shift (fun k -\u003e body)`\n\n4. **Evaluator** (`src/eval.rs`)\n   - Added `Frame::Prompt` for delimiting continuations\n   - Added `Value::Continuation { frames: Vec\u003cFrame\u003e }` for captured continuations\n   - `reset` pushes Prompt frame and evaluates body\n   - `shift` captures frames up to Prompt, binds continuation to parameter, evaluates body\n   - `Prompt` frame passes value through on completion\n   - Continuation application splices frames back and passes argument as result\n\n5. **Type Inference** (`src/infer.rs`)\n   - `reset e : a` where `e : a` (passthrough)\n   - `shift` uses simplified typing: `k : a -\u003e a, body : a, result : a`\n   - Full answer-type polymorphism deferred\n\n6. **Main** (`src/main.rs`)\n   - Added `Continuation` case to `print_value`\n\n### Tests Added\n- 13 new eval tests for delimited continuations\n- 3 new type inference tests\n\n### Examples Created\n- `examples/continuations_basic.gn` - basic reset/shift usage\n- `examples/continuations_escape.gn` - early exit pattern\n- `examples/continuations_collect.gn` - multiple invocations\n\n### Limitations\n- Simplified typing prevents some valid programs (e.g., collecting into list when inner computation returns different type)\n- Full answer-type polymorphism can be added later for more expressive types","status":"closed","priority":1,"issue_type":"feature","assignee":"claude","created_at":"2025-12-09T13:06:08.493189-05:00","updated_at":"2025-12-09T13:12:39.787255-05:00","closed_at":"2025-12-09T13:12:39.787255-05:00","labels":["concurrency","control-flow"]}
{"id":"gneiss-lang-d4s","title":"Implement property-based testing for type system soundness","description":"Add comprehensive property-based testing using `proptest` or `quickcheck` to ensure type system soundness and catch regressions. The Gneiss type system implements Hindley-Milner inference with let-polymorphism, mutable reference-based type variable linking (not yet a proper union-find), and support for ADTs, channels, and processes. Property-based testing is essential for:\n\n1. **Catching edge cases** in unification, occurs check, and level updates\n2. **Ensuring type safety invariants** hold across random well-typed programs\n3. **Finding soundness bugs** before they manifest in user code\n4. **Regression testing** as the type system evolves\n\nThis is critical infrastructure for maintaining soundness while iterating.\n\nNote: The current implementation uses `Rc\u003cRefCell\u003cTypeVar\u003e\u003e` with a `Link` variant for unification, but lacks path compression and union-by-rank (see gneiss-lang-6gf).","design":"## Implementation Strategy\n\n### Phase 1: Infrastructure Setup\n- Add `proptest` as a dev-dependency (preferred over quickcheck for better shrinking)\n- Create `tests/properties/` directory structure for property tests\n- Implement `Arbitrary` generators for core types\n\n### Phase 2: AST Generators\nCreate generators for well-formed AST nodes:\n```rust\n// Generate arbitrary expressions\nprop_compose! {\n    fn arb_literal()(kind in prop_oneof![\n        Just(LitKind::Int(42)),\n        any::\u003ci64\u003e().prop_map(LitKind::Int),\n        any::\u003cbool\u003e().prop_map(LitKind::Bool),\n        // ...\n    ]) -\u003e Expr { Expr::Literal(kind) }\n}\n\n// Generate well-scoped expressions (respecting variable binding)\nfn arb_expr_with_env(env: Vec\u003cString\u003e, depth: usize) -\u003e impl Strategy\u003cValue = Expr\u003e\n```\n\nKey insight: Generate *well-scoped* expressions to avoid trivial \"unbound variable\" failures.\n\n### Phase 3: Type Generators\n```rust\n// Generate arbitrary monomorphic types\nfn arb_mono_type(depth: usize) -\u003e impl Strategy\u003cValue = Type\u003e\n\n// Generate polymorphic type schemes\nfn arb_scheme() -\u003e impl Strategy\u003cValue = Scheme\u003e\n```\n\n### Phase 4: Core Soundness Properties\n\n**Property 1: Unification is symmetric**\n```rust\nproptest! {\n    fn unify_symmetric(t1: Type, t2: Type) {\n        let r1 = fresh_inferencer().unify(\u0026t1, \u0026t2);\n        let r2 = fresh_inferencer().unify(\u0026t2, \u0026t1);\n        assert_eq!(r1.is_ok(), r2.is_ok());\n    }\n}\n```\n\n**Property 2: Unification is idempotent**\n```rust\nproptest! {\n    fn unify_idempotent(t1: Type, t2: Type) {\n        let mut inf = fresh_inferencer();\n        if inf.unify(\u0026t1, \u0026t2).is_ok() {\n            // Unifying again should succeed and produce same result\n            assert!(inf.unify(\u0026t1, \u0026t2).is_ok());\n            assert_eq!(t1.resolve(), t2.resolve());\n        }\n    }\n}\n```\n\n**Property 3: Occurs check prevents infinite types**\n```rust\nproptest! {\n    fn occurs_check_sound(var_id: TypeVarId) {\n        let var = Type::new_var(var_id, 0);\n        let cyclic = Type::Arrow(Rc::new(var.clone()), Rc::new(var.clone()));\n        // Should detect the cycle\n        assert!(var.occurs(var_id) || cyclic.occurs(var_id));\n    }\n}\n```\n\n**Property 4: Type preservation (the big one)**\n```rust\nproptest! {\n    fn type_preservation(expr in arb_well_typed_expr()) {\n        let mut inf = Inferencer::new();\n        let ty = inf.infer(\u0026TypeEnv::new(), \u0026expr).unwrap();\n        let result = eval(\u0026Env::new(), \u0026expr);\n        // If eval succeeds, result should have inferred type\n        if let Ok(val) = result {\n            assert!(value_has_type(\u0026val, \u0026ty));\n        }\n        // If eval fails, it should be a runtime error, not type error\n    }\n}\n```\n\n**Property 5: Progress (well-typed programs don't get stuck)**\n```rust\nproptest! {\n    fn progress(expr in arb_well_typed_expr()) {\n        let result = eval(\u0026Env::new(), \u0026expr);\n        // Should either produce a value or a well-defined runtime error\n        // Should NOT panic or produce undefined behavior\n    }\n}\n```\n\n**Property 6: Let-polymorphism correctness**\n```rust\nproptest! {\n    fn let_poly_instantiation(body in arb_expr()) {\n        // let id = fun x -\u003e x in (id 1, id true)\n        // Should type-check with id : forall a. a -\u003e a\n        let id_def = /* ... */;\n        let usage = /* ... */;\n        // Both uses should succeed with different instantiations\n    }\n}\n```\n\n**Property 7: Generalization respects levels**\n```rust\nproptest! {\n    fn generalization_sound(expr in arb_let_expr()) {\n        // Type variables that escape their scope should not be generalized\n        let mut inf = Inferencer::new();\n        let result = inf.infer(\u0026env, \u0026expr);\n        if let Ok(ty) = result {\n            // Check that free type vars in ty are not generic\n        }\n    }\n}\n```\n\n### Phase 5: Pattern Matching Properties\n\n**Property 8: Exhaustiveness soundness**\n```rust\nproptest! {\n    fn exhaustive_patterns_complete(\n        adt_def in arb_adt_definition(),\n        patterns in arb_patterns_for_adt(\u0026adt_def)\n    ) {\n        // If patterns marked exhaustive, evaluation should never fall through\n    }\n}\n```\n\n### Phase 6: Concurrency Properties\n\n**Property 9: Channel type safety**\n```rust\nproptest! {\n    fn channel_types_preserved(msg_type: Type) {\n        // Channel\u003cInt\u003e should only accept/produce Int values\n    }\n}\n```\n\n### Phase 7: Fuzzing Integration\n- Use `cargo fuzz` for parser fuzzing\n- AFL/libfuzzer for finding crashes in type inference\n- Corpus seeding from example programs\n\n## Test Organization\n\n```\ntests/\n├── properties/\n│   ├── mod.rs\n│   ├── generators.rs      # Arbitrary impls\n│   ├── unification.rs     # Unification properties\n│   ├── inference.rs       # Type inference properties\n│   ├── preservation.rs    # Type preservation\n│   └── concurrency.rs     # Channel/spawn properties\n└── integration/\n    └── soundness.rs       # End-to-end property tests\n```\n\n## Complexity Budget\n- Start with simple generators, grow complexity incrementally\n- Use `prop_filter` sparingly (shrinking works poorly with heavy filtering)\n- Generate well-formed inputs rather than filtering malformed ones","acceptance_criteria":"1. **Dependencies added**: `proptest` in `Cargo.toml` dev-dependencies\n2. **Generators implemented**: \n   - `Arbitrary` for `Type`, `Expr`, `Pattern`, `Scheme`\n   - Well-scoped expression generator respecting variable bindings\n3. **Core properties tested**:\n   - [ ] Unification symmetry and idempotence\n   - [ ] Occurs check prevents infinite types\n   - [ ] Type preservation: well-typed programs evaluate to correctly-typed values\n   - [ ] Progress: well-typed programs don't get stuck\n   - [ ] Let-polymorphism instantiation works correctly\n   - [ ] Generalization respects escape analysis (levels)\n4. **Pattern matching properties**:\n   - [ ] Exhaustiveness checking is sound\n5. **Concurrency properties**:\n   - [ ] Channel types are preserved through send/recv\n6. **CI integration**: Property tests run in `cargo test`\n7. **Documentation**: Properties documented with their theoretical basis\n8. **Shrinking works**: Failures shrink to minimal counterexamples","notes":"## Implementation Progress\n\n### Completed\n- Added `proptest = \"1.5\"` as dev-dependency\n- Created `tests/properties.rs` with comprehensive property tests\n- Exposed `Inferencer::unify_types()` for testing\n\n### Properties Implemented\n1. **Unification properties** (3 tests)\n   - `unify_symmetric` - unify(a,b) succeeds iff unify(b,a) succeeds\n   - `unify_reflexive` - unify(a,a) always succeeds\n   - `unify_produces_equal_types` - after unification, types resolve to same\n\n2. **Occurs check properties** (2 tests)\n   - `occurs_check_detects_self_reference` - variable occurs in itself\n   - `occurs_check_negative` - variable doesn't occur in unrelated ground types\n\n3. **Type inference properties** (2 tests)\n   - `inference_deterministic` - same source yields same type\n   - `inference_does_not_panic` - inference never panics\n\n4. **Soundness properties** (2 tests)\n   - `type_preservation` - values match their inferred types\n   - `progress` - well-typed programs don't panic/get stuck\n\n5. **Let-polymorphism properties** (2 tests)\n   - `identity_is_polymorphic` - `let id = fun x -\u003e x` works at multiple types\n   - `const_is_polymorphic` - `let const = fun x -\u003e fun y -\u003e x` is polymorphic\n\n6. **Regression tests** (4 tests)\n   - `test_occurs_check_prevents_infinite_type`\n   - `test_let_polymorphism_basic`\n   - `test_value_restriction`\n   - `test_nested_let_polymorphism`\n\n### Bugs Found\n- Integer overflow in eval.rs:791 (filed as gneiss-lang-dwx)\n\n### Generators Available (for future expansion)\n- `arb_ground_type(depth)` - generates monomorphic types\n- `arb_type_with_vars(depth)` - types with fresh type variables\n- `arb_well_typed_source()` - valid Gneiss source strings\n- `arb_expr(env, depth)` - well-scoped AST expressions (reserved)","status":"closed","priority":1,"issue_type":"feature","assignee":"claude","created_at":"2025-12-09T10:31:13.009366-05:00","updated_at":"2025-12-09T10:47:38.278198-05:00","closed_at":"2025-12-09T10:47:38.278198-05:00","labels":["infrastructure","soundness","testing","type-system"],"dependencies":[{"issue_id":"gneiss-lang-d4s","depends_on_id":"gneiss-lang-6gf","type":"related","created_at":"2025-12-09T10:34:55.793226-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-dwx","title":"Integer arithmetic overflow in evaluator","description":"Property-based testing discovered that integer addition can panic with overflow when adding large i64 values.\n\n**Minimal failing case:**\n```\nlet x = 1913824111850683246 in x + 7309547925004092562\n```\nor\n```\n-3258846342380324963 + -5964525694474450846\n```\n\n**Location:** `src/eval.rs:791`\n\n**Impact:** Well-typed programs can panic, violating the progress property.","design":"Options:\n1. Use `checked_add` and return a runtime error on overflow\n2. Use `wrapping_add` for C-like wraparound semantics\n3. Use `saturating_add` to clamp to min/max values\n\nRecommendation: Use `checked_add` and return `EvalError::RuntimeError(\"integer overflow\")` - this is the most principled approach for a language that claims static typing prevents runtime errors.","acceptance_criteria":"- All integer arithmetic operations use checked variants\n- Overflow produces a well-defined `EvalError`, not a panic\n- Property test `progress` passes","status":"open","priority":2,"issue_type":"bug","created_at":"2025-12-09T10:38:55.782392-05:00","updated_at":"2025-12-09T10:38:55.782392-05:00","labels":["bug","found-by-proptest","runtime"]}
{"id":"gneiss-lang-g5a","title":"Add channel type safety property tests","description":"Add property-based tests for channel type safety in concurrent programs.\n\n**Properties to test:**\n1. `Channel\u003cInt\u003e` only accepts/produces `Int` values\n2. Type mismatches on send/recv are caught at type-check time\n3. The value restriction prevents unsound polymorphic channels\n\n**Requires:**\n- Generator for concurrent program fragments\n- Way to test channel operations without deadlocking","acceptance_criteria":"- Property test: channel types are preserved through send/recv\n- Property test: polymorphic channel bug is prevented by value restriction","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-09T10:44:09.812152-05:00","updated_at":"2025-12-09T10:44:09.812152-05:00","labels":["concurrency","proptest","testing"],"dependencies":[{"issue_id":"gneiss-lang-g5a","depends_on_id":"gneiss-lang-d4s","type":"blocks","created_at":"2025-12-09T10:44:09.813385-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-m3p","title":"Integration tests: producer-consumer, multiple channels","description":"Write integration tests for more complex concurrency patterns.\n\nTests to add:\n1. Producer-consumer: one process generates values, another consumes them\n2. Multiple channels: processes communicating over several channels\n3. Select usage: process waiting on multiple channels\n\nThese tests validate that the concurrency system works for real-world patterns, not just simple ping-pong.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-08T19:33:14.335458-05:00","updated_at":"2025-12-08T19:33:14.335458-05:00","dependencies":[{"issue_id":"gneiss-lang-m3p","depends_on_id":"gneiss-lang-94p","type":"parent-child","created_at":"2025-12-08T19:33:14.336128-05:00","created_by":"daemon"},{"issue_id":"gneiss-lang-m3p","depends_on_id":"gneiss-lang-mzz","type":"blocks","created_at":"2025-12-08T19:33:14.336766-05:00","created_by":"daemon"},{"issue_id":"gneiss-lang-m3p","depends_on_id":"gneiss-lang-yga","type":"blocks","created_at":"2025-12-08T19:33:14.337272-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-mzz","title":"Test: ping-pong between two processes","description":"Integration test proving two processes can communicate over a channel.\n\nTest case:\n1. Main spawns two processes\n2. Process A sends a value on channel\n3. Process B receives the value\n4. Both processes complete successfully\n\nThis validates the entire concurrency stack: spawn, channels, blocking, scheduler resumption.\n\nFile: examples/channel.gn already exists but doesn't work yet.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-08T19:33:02.550929-05:00","updated_at":"2025-12-09T00:15:05.943437-05:00","closed_at":"2025-12-09T00:15:05.943437-05:00","dependencies":[{"issue_id":"gneiss-lang-mzz","depends_on_id":"gneiss-lang-94p","type":"parent-child","created_at":"2025-12-08T19:33:02.55194-05:00","created_by":"daemon"},{"issue_id":"gneiss-lang-mzz","depends_on_id":"gneiss-lang-z43","type":"blocks","created_at":"2025-12-08T19:33:02.552851-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-q2d","title":"CPS transform the interpreter","description":"Convert eval to continuation-passing style so processes can suspend and resume.\n\nCurrently eval is synchronous - when a process hits Channel.recv, it returns immediately with Unit instead of suspending. CPS will allow blocking operations to capture \"what to do next\" and return control to the scheduler.\n\nKey changes:\n- eval takes a continuation parameter\n- Blocking ops (send/recv) capture continuation and return to scheduler\n- Non-blocking ops invoke continuation directly\n\nCritical file: src/eval.rs","notes":"Implemented defunctionalized CPS interpreter:\n\n- Added Frame enum representing continuation frames (stack-based)\n- Added Cont struct as the continuation stack  \n- Added State enum (Eval/Apply modes)\n- Added StepResult enum for step outcomes (Continue/Done/Blocked/Error)\n- Converted eval to step-based machine with step_eval and step_apply\n- All existing tests pass (21/21)\n- REPL works correctly\n\nThe interpreter now supports suspension via StepResult::Blocked, which will be used for channel operations. The continuation stack (Cont) can be saved when a process blocks and restored when it resumes.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-08T19:32:44.543759-05:00","updated_at":"2025-12-08T19:51:36.474232-05:00","closed_at":"2025-12-08T19:51:36.474232-05:00","dependencies":[{"issue_id":"gneiss-lang-q2d","depends_on_id":"gneiss-lang-94p","type":"parent-child","created_at":"2025-12-08T19:32:44.544459-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-t7b","title":"Optimize type inference with union-find","description":"Current type variable unification uses naive linked representation without union-find optimizations.\n\nCurrent approach (types.rs, infer.rs):\n- TypeVar::Link just points to another type\n- resolve() follows chain every time - O(n) per lookup\n- No path compression\n- No union by rank\n\nShould implement:\n1. Path compression in resolve() - update intermediate links to point to root\n2. Union by rank - track tree depth, attach shorter under taller\n\nLow priority - works fine for small programs, but would improve performance for larger codebases.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-08T19:54:39.33895-05:00","updated_at":"2025-12-08T19:54:39.33895-05:00","labels":["optimization","type-system"]}
{"id":"gneiss-lang-yga","title":"Implement basic select","description":"Implement select for waiting on multiple channels.\n\nCurrently returns error: \"select not yet implemented\" (eval.rs line 365-367).\n\nRequirements:\n- Wait on multiple receive operations\n- Non-deterministic choice when multiple channels ready\n- Return the value from whichever channel fires first\n\nSyntax already parsed: select [ ch1 -\u003e handler1 | ch2 -\u003e handler2 ]\n\nCritical file: src/eval.rs","notes":"## Implementation Complete\n\n### Changes Made\n\n**Lexer (`src/lexer.rs`):**\n- Added tokens: `Select`, `End`, `LArrow` (`\u003c-`)\n- Added keyword recognition for `select` and `end`\n- Added `\u003c-` operator lexing\n\n**Parser (`src/parser.rs`):**\n- Added `parse_select()` method for the new syntax:\n  ```\n  select\n  | pattern \u003c- channel_expr -\u003e body_expr\n  | pattern \u003c- channel_expr -\u003e body_expr\n  end\n  ```\n- Integrated into expression parsing\n\n**Type Inference (`src/infer.rs`):**\n- Proper type checking for select:\n  - Channels must be `Channel\u003cT\u003e` types\n  - Patterns bind to channel element type\n  - All arm bodies must return compatible types\n- Added type inference tests\n\n**Runtime (`src/runtime.rs`):**\n- Added `ProcessState::BlockedSelect(Vec\u003cChannelId\u003e)` for processes blocked on select\n- Added `ProcessContinuation::ResumeAfterSelect` for proper resumption\n- Added `select_fired_channel` field to `Process` to track which channel fired\n- Added `try_recv()` for non-blocking receive (used by select)\n- Added `block_on_select()` to register on multiple channels\n- Updated `send()` to handle waking select-blocked receivers\n- Updated `is_deadlocked()` to only detect true deadlocks (main blocked, not just spawned processes)\n- Added `main_pid` tracking\n\n**Eval (`src/eval.rs`):**\n- Added `Frame::SelectChans` for evaluating channel expressions\n- Added `Frame::SelectReady` for performing the select\n- Added `BlockReason::Select` for blocked state\n- Proper handling of select resumption after being woken\n\n### Tests Added\n- `test_select_basic` - basic select with one active channel\n- `test_select_second_channel` - select where second arm fires\n- `test_select_with_pattern` - select with tuple pattern matching\n- `test_select_deadlock_no_senders` - deadlock detection works\n- `test_select_multiple_ready` - non-deterministic choice when multiple ready\n- `test_select_server_pattern` - request/response pattern\n- `test_select_type_inference_consistent` - type inference succeeds\n- `test_select_type_inference_mismatch` - type inference rejects mismatched types\n\nAll 55 tests pass.","status":"closed","priority":2,"issue_type":"task","assignee":"claude","created_at":"2025-12-08T19:33:08.377697-05:00","updated_at":"2025-12-09T12:26:01.844039-05:00","closed_at":"2025-12-09T12:26:01.844039-05:00","dependencies":[{"issue_id":"gneiss-lang-yga","depends_on_id":"gneiss-lang-94p","type":"parent-child","created_at":"2025-12-08T19:33:08.378447-05:00","created_by":"daemon"},{"issue_id":"gneiss-lang-yga","depends_on_id":"gneiss-lang-z43","type":"blocks","created_at":"2025-12-08T19:33:08.379189-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-z43","title":"Wire up scheduler to resume processes","description":"Fix run_scheduler to actually resume blocked processes with their continuation.\n\nCurrently run_scheduler (eval.rs lines 635-678) immediately marks processes Done after AfterRecv/AfterSend instead of resuming execution. Need to:\n\n- Store the captured continuation when process blocks\n- When unblocked, resume by invoking continuation with received value\n- Properly interleave multiple processes\n\nCritical file: src/eval.rs (run_scheduler function)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-08T19:32:57.271102-05:00","updated_at":"2025-12-08T22:43:41.619171-05:00","closed_at":"2025-12-08T22:43:41.619171-05:00","dependencies":[{"issue_id":"gneiss-lang-z43","depends_on_id":"gneiss-lang-94p","type":"parent-child","created_at":"2025-12-08T19:32:57.27175-05:00","created_by":"daemon"},{"issue_id":"gneiss-lang-z43","depends_on_id":"gneiss-lang-3xz","type":"blocks","created_at":"2025-12-08T19:32:57.27233-05:00","created_by":"daemon"}]}
