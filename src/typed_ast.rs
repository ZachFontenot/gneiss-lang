//! Typed Abstract Syntax Tree
//!
//! This module defines a typed AST where each expression node is annotated
//! with its inferred type. This enables:
//! 1. Tests that inspect types of sub-expressions
//! 2. Verification that constraints are properly attached
//! 3. Foundation for future compilation passes (codegen needs types)

use crate::ast::{BinOp, Ident, Literal, Span, UnaryOp};
use crate::types::{Pred, Scheme, Type};
use std::rc::Rc;

// ============================================================================
// Typed Expressions
// ============================================================================

/// A typed expression - an expression annotated with its inferred type
#[derive(Debug, Clone)]
pub struct TExpr {
    /// The expression kind
    pub kind: TExprKind,
    /// The inferred type of this expression
    pub ty: Type,
    /// Source span for error reporting
    pub span: Span,
}

impl TExpr {
    pub fn new(kind: TExprKind, ty: Type, span: Span) -> Self {
        Self { kind, ty, span }
    }
}

/// Typed expression kinds - mirrors ExprKind but with typed children
#[derive(Debug, Clone)]
pub enum TExprKind {
    // Literals
    Lit(Literal),

    // Variable reference - includes the scheme it was instantiated from
    Var {
        name: Ident,
        /// The scheme this variable had before instantiation (for let-bound vars)
        scheme: Option<Scheme>,
        /// Predicates generated by instantiation (e.g., Show a when calling `show`)
        instantiated_preds: Vec<Pred>,
    },

    // Lambda
    Lambda {
        params: Vec<TPattern>,
        body: Rc<TExpr>,
    },

    // Application
    App {
        func: Rc<TExpr>,
        arg: Rc<TExpr>,
    },

    // Let binding - includes the generalized scheme for the bound variable
    Let {
        pattern: TPattern,
        /// The scheme assigned to the bound variable (may be polymorphic)
        scheme: Scheme,
        value: Rc<TExpr>,
        body: Option<Rc<TExpr>>,
    },

    // Recursive let bindings
    LetRec {
        bindings: Vec<TRecBinding>,
        body: Option<Rc<TExpr>>,
    },

    // If expression
    If {
        cond: Rc<TExpr>,
        then_branch: Rc<TExpr>,
        else_branch: Rc<TExpr>,
    },

    // Match expression
    Match {
        scrutinee: Rc<TExpr>,
        arms: Vec<TMatchArm>,
    },

    // Tuple
    Tuple(Vec<TExpr>),

    // List
    List(Vec<TExpr>),

    // Constructor application
    Constructor {
        name: Ident,
        args: Vec<TExpr>,
    },

    // Binary operator
    BinOp {
        op: BinOp,
        left: Rc<TExpr>,
        right: Rc<TExpr>,
    },

    // Unary operator
    UnaryOp {
        op: UnaryOp,
        operand: Rc<TExpr>,
    },

    // Sequencing
    Seq {
        first: Rc<TExpr>,
        second: Rc<TExpr>,
    },

    // ========================================================================
    // Concurrency primitives
    // ========================================================================
    Spawn(Rc<TExpr>),
    NewChannel,
    ChanSend {
        channel: Rc<TExpr>,
        value: Rc<TExpr>,
    },
    ChanRecv(Rc<TExpr>),
    Select {
        arms: Vec<TSelectArm>,
    },

    // ========================================================================
    // Algebraic Effects
    // ========================================================================
    Perform {
        effect: Ident,
        operation: Ident,
        args: Vec<TExpr>,
    },
    Handle {
        body: Rc<TExpr>,
        return_clause: THandlerReturn,
        handlers: Vec<THandlerArm>,
    },

    // ========================================================================
    // Records
    // ========================================================================
    Record {
        name: Ident,
        fields: Vec<(Ident, TExpr)>,
    },
    FieldAccess {
        record: Rc<TExpr>,
        field: Ident,
    },
    RecordUpdate {
        base: Rc<TExpr>,
        updates: Vec<(Ident, TExpr)>,
    },

    // Typed hole
    Hole,
}

// ============================================================================
// Typed Patterns
// ============================================================================

/// A typed pattern
#[derive(Debug, Clone)]
pub struct TPattern {
    pub kind: TPatternKind,
    /// The type this pattern matches against
    pub ty: Type,
    pub span: Span,
}

#[derive(Debug, Clone)]
pub enum TPatternKind {
    /// Variable binding
    Var(Ident),
    /// Wildcard _
    Wildcard,
    /// Literal pattern
    Lit(Literal),
    /// Constructor pattern
    Constructor {
        name: Ident,
        args: Vec<TPattern>,
    },
    /// Tuple pattern
    Tuple(Vec<TPattern>),
    /// List pattern [a, b, c]
    List(Vec<TPattern>),
    /// Cons pattern h :: t
    Cons {
        head: Box<TPattern>,
        tail: Box<TPattern>,
    },
    /// Record pattern { field1, field2 = pat }
    Record {
        name: Ident,
        fields: Vec<(Ident, Option<TPattern>)>,
    },
}

// ============================================================================
// Supporting structures
// ============================================================================

#[derive(Debug, Clone)]
pub struct TMatchArm {
    pub pattern: TPattern,
    pub guard: Option<TExpr>,
    pub body: TExpr,
}

#[derive(Debug, Clone)]
pub struct TSelectArm {
    pub channel: TExpr,
    pub pattern: TPattern,
    pub body: TExpr,
}

#[derive(Debug, Clone)]
pub struct THandlerReturn {
    pub pattern: TPattern,
    pub body: Box<TExpr>,
}

#[derive(Debug, Clone)]
pub struct THandlerArm {
    pub operation: Ident,
    pub params: Vec<TPattern>,
    pub continuation: Ident,
    pub body: Box<TExpr>,
}

#[derive(Debug, Clone)]
pub struct TRecBinding {
    pub name: Ident,
    /// The scheme for this recursive binding
    pub scheme: Scheme,
    pub params: Vec<TPattern>,
    pub body: TExpr,
}

// ============================================================================
// Typed Program
// ============================================================================

/// A typed program
#[derive(Debug, Clone)]
pub struct TProgram {
    pub items: Vec<TItem>,
}

/// A typed top-level item
#[derive(Debug, Clone)]
pub enum TItem {
    /// A typed declaration
    Decl(TDecl),
    /// Type declarations pass through unchanged (they don't have runtime values)
    TypeDecl {
        name: Ident,
        params: Vec<Ident>,
        constructors: Vec<(Ident, Vec<Type>)>,
    },
    /// Trait declarations
    TraitDecl {
        name: Ident,
        param: Ident,
        methods: Vec<(Ident, Scheme)>,
    },
    /// Instance declarations
    InstanceDecl {
        trait_name: Ident,
        for_type: Type,
        methods: Vec<(Ident, TExpr)>,
    },
    /// Effect declarations
    EffectDecl {
        name: Ident,
        operations: Vec<(Ident, Type)>,
    },
    /// Module declarations
    Module {
        name: Ident,
        items: Vec<TItem>,
    },
}

/// A typed declaration
#[derive(Debug, Clone)]
pub enum TDecl {
    /// Let binding at top level
    Let {
        pattern: TPattern,
        scheme: Scheme,
        value: TExpr,
    },
    /// Recursive let bindings at top level
    LetRec {
        bindings: Vec<TRecBinding>,
    },
}

// ============================================================================
// Utility functions for inspection
// ============================================================================

impl TExpr {
    /// Find a let-bound variable by name and return its scheme
    pub fn find_let_binding(&self, name: &str) -> Option<&Scheme> {
        match &self.kind {
            TExprKind::Let { pattern, scheme, body, .. } => {
                if let TPatternKind::Var(n) = &pattern.kind {
                    if n == name {
                        return Some(scheme);
                    }
                }
                if let Some(body) = body {
                    body.find_let_binding(name)
                } else {
                    None
                }
            }
            TExprKind::LetRec { bindings, body } => {
                for binding in bindings {
                    if binding.name == name {
                        return Some(&binding.scheme);
                    }
                }
                if let Some(body) = body {
                    body.find_let_binding(name)
                } else {
                    None
                }
            }
            TExprKind::Lambda { body, .. } => body.find_let_binding(name),
            TExprKind::App { func, arg } => {
                func.find_let_binding(name).or_else(|| arg.find_let_binding(name))
            }
            TExprKind::If { cond, then_branch, else_branch } => {
                cond.find_let_binding(name)
                    .or_else(|| then_branch.find_let_binding(name))
                    .or_else(|| else_branch.find_let_binding(name))
            }
            TExprKind::Match { scrutinee, arms } => {
                scrutinee.find_let_binding(name).or_else(|| {
                    arms.iter().find_map(|arm| arm.body.find_let_binding(name))
                })
            }
            TExprKind::Seq { first, second } => {
                first.find_let_binding(name).or_else(|| second.find_let_binding(name))
            }
            _ => None,
        }
    }

    /// Collect all variable references with their instantiated predicates
    pub fn collect_var_instantiations(&self) -> Vec<(&str, &[Pred])> {
        let mut result = Vec::new();
        self.collect_var_instantiations_inner(&mut result);
        result
    }

    fn collect_var_instantiations_inner<'a>(&'a self, result: &mut Vec<(&'a str, &'a [Pred])>) {
        match &self.kind {
            TExprKind::Var { name, instantiated_preds, .. } => {
                if !instantiated_preds.is_empty() {
                    result.push((name.as_str(), instantiated_preds.as_slice()));
                }
            }
            TExprKind::Lambda { body, .. } => body.collect_var_instantiations_inner(result),
            TExprKind::App { func, arg } => {
                func.collect_var_instantiations_inner(result);
                arg.collect_var_instantiations_inner(result);
            }
            TExprKind::Let { value, body, .. } => {
                value.collect_var_instantiations_inner(result);
                if let Some(body) = body {
                    body.collect_var_instantiations_inner(result);
                }
            }
            TExprKind::LetRec { bindings, body } => {
                for binding in bindings {
                    binding.body.collect_var_instantiations_inner(result);
                }
                if let Some(body) = body {
                    body.collect_var_instantiations_inner(result);
                }
            }
            TExprKind::If { cond, then_branch, else_branch } => {
                cond.collect_var_instantiations_inner(result);
                then_branch.collect_var_instantiations_inner(result);
                else_branch.collect_var_instantiations_inner(result);
            }
            TExprKind::Match { scrutinee, arms } => {
                scrutinee.collect_var_instantiations_inner(result);
                for arm in arms {
                    arm.body.collect_var_instantiations_inner(result);
                }
            }
            TExprKind::Seq { first, second } => {
                first.collect_var_instantiations_inner(result);
                second.collect_var_instantiations_inner(result);
            }
            TExprKind::Tuple(exprs) | TExprKind::List(exprs) => {
                for expr in exprs {
                    expr.collect_var_instantiations_inner(result);
                }
            }
            TExprKind::BinOp { left, right, .. } => {
                left.collect_var_instantiations_inner(result);
                right.collect_var_instantiations_inner(result);
            }
            _ => {}
        }
    }
}
