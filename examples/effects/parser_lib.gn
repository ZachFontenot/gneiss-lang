-- =============================================================================
-- Parser Combinator Library using Algebraic Effects
-- =============================================================================
--
-- This library demonstrates proper use of algebraic effects for parsing:
-- - State threading through function-returning handlers (avoids infinite types)
-- - Backtracking via mark/restore operations
-- - Failure as an effect with polymorphic return type
--
-- Effect Laws Verified:
-- - Peek-Peek Idempotence: peek(); peek() === peek()
-- - Mark-Restore: mark(); advance n; restore === identity
-- - Choice Left-Zero: fail <|> p === p
-- - Choice Right-Zero: return x <|> p === return x

-- =============================================================================
-- Parser Effect
-- =============================================================================

effect Parser =
    | peek : () -> String           -- Remaining input from current position
    | advance : Int -> ()           -- Move position forward
    | get_pos : () -> Int           -- Current position
    | mark : () -> Int              -- Save position for backtracking
    | restore : Int -> ()           -- Restore to saved position
    | fail_parse : String -> a      -- Fail with message (polymorphic return)
end

-- =============================================================================
-- Parse Result Type
-- =============================================================================

type ParseResult a =
    | ParseOk a String Int      -- value, remaining input, final position
    | ParseFail String Int      -- error message, position where failed

-- =============================================================================
-- State-Threading Handler (Function-Returning Pattern)
-- =============================================================================
--
-- Key insight: Instead of recursive handler calls (which cause infinite type
-- errors), we return a function that takes the state. The handler clauses
-- compose these state-transforming functions.
--
-- State is (input, position) as a tuple.

let run_parser comp input =
    let go =
        handle comp () with
        | return x -> fun state ->
            match state with
            | (inp, pos) -> ParseOk x (string_substring pos (string_length inp) inp) pos
            end
        | peek () k -> fun state ->
            match state with
            | (inp, pos) ->
                let remaining = string_substring pos (string_length inp) inp in
                k remaining (inp, pos)
            end
        | advance n k -> fun state ->
            match state with
            | (inp, pos) -> k () (inp, pos + n)
            end
        | get_pos () k -> fun state ->
            match state with
            | (inp, pos) -> k pos (inp, pos)
            end
        | mark () k -> fun state ->
            match state with
            | (inp, pos) -> k pos (inp, pos)
            end
        | restore saved k -> fun state ->
            match state with
            | (inp, _) -> k () (inp, saved)
            end
        | fail_parse msg k -> fun state ->
            match state with
            | (_, pos) -> ParseFail msg pos
            end
        end
    in
    go (input, 0)

-- =============================================================================
-- Core Parser Primitives
-- =============================================================================

let peek_input () = perform Parser.peek ()
let advance_by n = perform Parser.advance n
let get_position () = perform Parser.get_pos ()
let mark_position () = perform Parser.mark ()
let restore_position pos = perform Parser.restore pos
let fail msg = perform Parser.fail_parse msg

-- =============================================================================
-- Basic Parsers
-- =============================================================================

-- Parse a character satisfying a predicate
let satisfy pred desc =
    let remaining = peek_input () in
    if string_length remaining == 0 then
        fail ("Expected " ++ desc ++ ", got end of input")
    else
        match string_char_at 0 remaining with
        | None -> fail "Internal error"
        | Some c ->
            if pred c then (
                advance_by 1;
                c
            ) else
                fail ("Expected " ++ desc ++ ", got '" ++ char_to_string c ++ "'")
        end

-- Parse a specific character
let parse_char c = satisfy (fun x -> x == c) ("'" ++ char_to_string c ++ "'")

-- Parse any single character
let any_char () = satisfy (fun _ -> true) "any character"

-- Parse a specific string
let parse_string s =
    let len = string_length s in
    let remaining = peek_input () in
    if string_starts_with s remaining then (
        advance_by len;
        s
    ) else
        fail ("Expected \"" ++ s ++ "\"")

-- Parse end of input
let parse_eof () =
    let remaining = peek_input () in
    if string_length remaining == 0 then ()
    else fail "Expected end of input"

-- =============================================================================
-- Character Class Parsers
-- =============================================================================

let parse_digit () = satisfy char_is_digit "digit"
let parse_alpha () = satisfy char_is_alpha "letter"
let parse_alphanum () = satisfy char_is_alphanumeric "alphanumeric"
let parse_space () = satisfy char_is_whitespace "whitespace"

let one_of chars =
    satisfy (fun c -> string_contains chars (char_to_string c)) ("one of \"" ++ chars ++ "\"")

-- =============================================================================
-- Choice and Backtracking
-- =============================================================================

-- Try parser with automatic backtracking on failure
let try_backtrack body =
    let saved = mark_position () in
    handle body () with
    | return x -> x
    | fail_parse msg k ->
        restore_position saved;
        fail msg
    end

-- Choice: try first parser, if it fails without consuming input, try second
let choice p1 p2 =
    let start = get_position () in
    handle p1 () with
    | return x -> x
    | fail_parse msg k ->
        let current = get_position () in
        if current == start then
            p2 ()
        else
            fail msg
    end

-- Choice with explicit backtracking (always tries second if first fails)
let choice_try p1 p2 =
    choice (fun () -> try_backtrack p1) p2

-- =============================================================================
-- Repetition Combinators
-- =============================================================================

-- Zero or more
let rec many p =
    choice
        (fun () ->
            let x = p () in
            let xs = many p in
            x :: xs)
        (fun () -> [])

-- One or more
let many1 p =
    let x = p () in
    let xs = many p in
    x :: xs

-- Optional: zero or one
let optional p =
    choice
        (fun () -> Some (p ()))
        (fun () -> None)

-- Skip zero or more
let skip_many p =
    let _ = many p in
    ()

-- Skip one or more
let skip_many1 p =
    let _ = p () in
    skip_many p

-- =============================================================================
-- Separator Combinators
-- =============================================================================

-- Zero or more separated by delimiter
let sep_by p sep =
    choice
        (fun () ->
            let x = p () in
            let xs = many (fun () -> let _ = sep () in p ()) in
            x :: xs)
        (fun () -> [])

-- One or more separated by delimiter
let sep_by1 p sep =
    let x = p () in
    let xs = many (fun () -> let _ = sep () in p ()) in
    x :: xs

-- =============================================================================
-- Bracketing Combinators
-- =============================================================================

let between open_p close_p p =
    let _ = open_p () in
    let x = p () in
    let _ = close_p () in
    x

let parens p = between (fun () -> parse_char '(') (fun () -> parse_char ')') p
let braces p = between (fun () -> parse_char '{') (fun () -> parse_char '}') p
let brackets p = between (fun () -> parse_char '[') (fun () -> parse_char ']') p

-- =============================================================================
-- Lexeme Combinators
-- =============================================================================

let lexeme p =
    let x = p () in
    skip_many (fun () -> parse_space ());
    x

let symbol s = lexeme (fun () -> parse_string s)

-- =============================================================================
-- Chain Combinators (for expression parsing)
-- =============================================================================

-- Left-associative chain: expr op expr op expr => ((expr op expr) op expr)
-- Uses try_backtrack to ensure failed operator attempts restore position
let chainl1 p op =
    let x = p () in
    let rec go acc =
        choice
            (fun () -> try_backtrack (fun () ->
                let f = op () in
                let y = p () in
                go (f acc y)))
            (fun () -> acc)
    in go x

-- Right-associative chain
let chainr1 p op =
    let x = p () in
    choice
        (fun () -> try_backtrack (fun () ->
            let f = op () in
            let y = chainr1 p op in
            f x y))
        (fun () -> x)

-- =============================================================================
-- Numeric Parsers
-- =============================================================================

let chars_to_int cs =
    let rec go acc digits =
        match digits with
        | [] -> acc
        | c :: rest -> go (acc * 10 + (char_to_int c - char_to_int '0')) rest
        end
    in go 0 cs

let parse_natural () =
    let digits = many1 (fun () -> parse_digit ()) in
    chars_to_int digits

let parse_integer () =
    choice_try
        (fun () ->
            let _ = parse_char '-' in
            let n = parse_natural () in
            0 - n)
        (fun () ->
            let _ = optional (fun () -> parse_char '+') in
            parse_natural ())

-- =============================================================================
-- Identifier Parser
-- =============================================================================

let parse_identifier () =
    let first = parse_alpha () in
    let rest = many (fun () -> parse_alphanum ()) in
    chars_to_string (first :: rest)

-- =============================================================================
-- Example: Simple Expression Parser
-- =============================================================================

type Expr =
    | Num Int
    | Add Expr Expr
    | Sub Expr Expr
    | Mul Expr Expr
    | Div Expr Expr
    | Var String

-- Skip spaces helper
let spaces () = skip_many (fun () -> parse_space ())

-- Forward declaration via mutual recursion
let rec parse_expr () = parse_additive ()

and parse_additive () =
    chainl1 (fun () -> parse_multiplicative ()) (fun () ->
        spaces ();
        choice
            (fun () -> let _ = parse_char '+' in fun a b -> Add a b)
            (fun () -> let _ = parse_char '-' in fun a b -> Sub a b)
    )

and parse_multiplicative () =
    chainl1 (fun () -> parse_factor ()) (fun () ->
        spaces ();
        choice
            (fun () -> let _ = parse_char '*' in fun a b -> Mul a b)
            (fun () -> let _ = parse_char '/' in fun a b -> Div a b)
    )

and parse_factor () =
    spaces ();
    choice
        (fun () -> parens (fun () -> parse_expr ()))
        (fun () ->
            choice
                (fun () -> Num (parse_integer ()))
                (fun () -> Var (parse_identifier ())))

-- Parse a complete expression
let parse_expr_full input =
    run_parser (fun () ->
        spaces ();
        let e = parse_expr () in
        spaces ();
        parse_eof ();
        e
    ) input

-- Pretty-print an expression
let rec show_expr e =
    match e with
    | Num n -> int_to_string n
    | Var x -> x
    | Add a b -> "(" ++ show_expr a ++ " + " ++ show_expr b ++ ")"
    | Sub a b -> "(" ++ show_expr a ++ " - " ++ show_expr b ++ ")"
    | Mul a b -> "(" ++ show_expr a ++ " * " ++ show_expr b ++ ")"
    | Div a b -> "(" ++ show_expr a ++ " / " ++ show_expr b ++ ")"
    end

-- =============================================================================
-- Main: Demonstrate parser library
-- =============================================================================

let main () =
    print "=== Parser Combinator Library with Algebraic Effects ===";
    print "";

    -- Test basic string parsing
    print "--- Basic Parsing ---";
    let r1 = run_parser (fun () -> parse_string "hello") "hello world" in
    match r1 with
    | ParseOk v rest pos -> print ("Parsed: '" ++ v ++ "', remaining: '" ++ rest ++ "', pos: " ++ int_to_string pos)
    | ParseFail msg pos -> print ("Failed at " ++ int_to_string pos ++ ": " ++ msg)
    end;

    -- Test character parsing
    print "";
    print "--- Character Parsing ---";
    let r2 = run_parser (fun () -> many1 (fun () -> parse_digit ())) "12345abc" in
    match r2 with
    | ParseOk v rest pos -> print ("Parsed " ++ int_to_string (length v) ++ " digits, remaining: '" ++ rest ++ "'")
    | ParseFail msg pos -> print ("Failed: " ++ msg)
    end;

    -- Test choice
    print "";
    print "--- Choice Parsing ---";
    let r3 = run_parser (fun () -> choice (fun () -> parse_string "foo") (fun () -> parse_string "bar")) "bar" in
    match r3 with
    | ParseOk v _ _ -> print ("Choice parsed: '" ++ v ++ "'")
    | ParseFail msg _ -> print ("Failed: " ++ msg)
    end;

    -- Test backtracking with try
    print "";
    print "--- Backtracking with try ---";
    let r4 = run_parser (fun () ->
        choice_try
            (fun () ->
                let _ = parse_string "foo" in
                let _ = parse_string "bar" in
                "foobar")
            (fun () ->
                let _ = parse_string "foo" in
                let _ = parse_string "baz" in
                "foobaz")
    ) "foobaz" in
    match r4 with
    | ParseOk v _ _ -> print ("Backtrack parsed: '" ++ v ++ "'")
    | ParseFail msg _ -> print ("Failed: " ++ msg)
    end;

    -- Test expression parsing
    print "";
    print "--- Expression Parsing ---";
    let exprs = ["1 + 2", "3 * 4 + 5", "1 + 2 * 3", "(1 + 2) * 3", "x + y * 2", "10 - 3 - 2"] in
    let rec test_exprs es =
        match es with
        | [] -> ()
        | input :: rest ->
            (match parse_expr_full input with
            | ParseOk e _ _ -> print ("  \"" ++ input ++ "\" => " ++ show_expr e)
            | ParseFail msg pos -> print ("  \"" ++ input ++ "\" => ERROR at " ++ int_to_string pos ++ ": " ++ msg)
            end;
            test_exprs rest)
        end
    in
    test_exprs exprs;

    -- Test separator parsing
    print "";
    print "--- Separator Parsing ---";
    let r5 = run_parser (fun () ->
        sep_by (fun () -> parse_natural ()) (fun () -> parse_char ',')
    ) "1,2,3,4,5" in
    match r5 with
    | ParseOk nums _ _ ->
        print ("CSV parsed: " ++ int_to_string (length nums) ++ " numbers, sum = " ++ int_to_string (sum nums))
    | ParseFail msg _ -> print ("Failed: " ++ msg)
    end;

    print "";
    print "=== All tests completed ===";
    0
