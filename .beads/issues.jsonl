{"id":"gneiss-lang-0e9","title":"Add generalization level tracking property tests","description":"Add property-based tests verifying that type variable levels are tracked correctly for let-polymorphism.\n\n**Property to test:**\nType variables that \"escape\" their scope (are used outside the let body where they were introduced) should NOT be generalized.\n\n**Example of what should fail:**\n```\nfun x -\u003e let y = x in y  -- x escapes, should not be generalized\n```\n\n**Requires:**\n- Generator for let expressions with escaping variables\n- Way to inspect whether a type variable was generalized","acceptance_criteria":"- Property test: escaping type variables are not generalized\n- Property test: non-escaping type variables at appropriate level are generalized","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-09T10:44:10.15267-05:00","updated_at":"2025-12-09T10:44:10.15267-05:00","labels":["proptest","testing","type-system"],"dependencies":[{"issue_id":"gneiss-lang-0e9","depends_on_id":"gneiss-lang-d4s","type":"blocks","created_at":"2025-12-09T10:44:10.153766-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-1dd","title":"Type system limitation: occurs check rejects valid continuation patterns","description":"The current simplified typing for shift/reset rejects some valid programs due to the occurs check.\n\n**Problem:**\nPatterns like `reset (shift (fun k -\u003e k))` fail with \"occurs check failed: 1 occurs in t1 -\u003e t1\". This is because:\n- `k` has type `a -\u003e a` (continuation preserves answer type)\n- Returning `k` directly creates type `(a -\u003e a)` for the shift body\n- But `k`'s return type must equal shift's type, creating `a = a -\u003e a` (infinite type)\n\n**Affected patterns:**\n```gneiss\n-- All of these fail type checking:\nreset (shift (fun k -\u003e k))                    -- return continuation itself\nlet k = reset (shift (fun k -\u003e k)) in k 1     -- store and use later\nreset (shift (fun k1 -\u003e k1 (shift (fun k2 -\u003e k2 100)))) + 1  -- nested shifts\n```\n\n**Root cause:**\nThe simplified typing rule `k : τ → τ` (answer type preserved) is too restrictive. Full shift/reset typing uses answer-type modification:\n```\nΓ ⊢ shift k. body : τ, α/β\nwhere k : (τ → α) → β\n```\n\nThis allows the continuation to change the answer type.\n\n**Impact:**\n- Cannot return continuations directly from shift\n- Cannot compose continuations in certain ways\n- Some canonical delimited continuation examples don't work\n\n**Workaround:**\nUse the continuation immediately within the shift body rather than returning it.\n\n**References:**\n- Asai \u0026 Kiselyov \"Introduction to Programming with Shift and Reset\"\n- docs/delim_cont_2.md Section 5 (Type System Considerations)","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-11T20:58:10.378727-05:00","updated_at":"2025-12-11T20:58:10.378727-05:00","labels":["continuations","limitation","type-system"]}
{"id":"gneiss-lang-1wm","title":"Stale TODO comment in infer.rs:1037","description":"There's a stale TODO comment at `src/infer.rs:1037`:\n```\n// TODO: In Phase 5, we'll discharge predicates here and check for unsatisfied constraints\n// For now, predicates are collected but not checked\n```\n\nPhase 5 (instance resolution) has been completed. This comment should either be:\n1. Removed if predicate discharge is handled elsewhere\n2. Updated to reflect actual current status\n\nPre-existing issue, not introduced this session.","status":"open","priority":4,"issue_type":"chore","created_at":"2025-12-11T18:31:27.218214-05:00","updated_at":"2025-12-11T18:31:27.218214-05:00","labels":["cleanup","documentation"]}
{"id":"gneiss-lang-1xe","title":"Add module-related tokens to lexer","description":"Add tokens for module system syntax:\n- `module` - module declaration keyword\n- `import` - import statement keyword  \n- `export` - export statement keyword (if using explicit exports)\n- `as` - for qualified imports\n- `private` - for private declarations\n\nUpdate keyword matching in scan_identifier().","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-11T19:18:51.749822-05:00","updated_at":"2025-12-11T19:18:51.749822-05:00","labels":["lexer","modules","phase-3"],"dependencies":[{"issue_id":"gneiss-lang-1xe","depends_on_id":"gneiss-lang-drf","type":"blocks","created_at":"2025-12-11T19:18:51.751053-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-25y","title":"Remove infer_expr compatibility shim when callers migrated","description":"Current implementation has two entry points:\n- infer_expr() - returns just Type (compatibility wrapper)\n- infer_expr_full() - returns InferResult with answer types\n\nOnce full answer-type threading is implemented and callers are ready, consider:\n1. Removing the shim and making infer_expr_full the main entry\n2. Or keeping both for different use cases\n\nDepends on full answer-type threading being complete.","status":"open","priority":4,"issue_type":"chore","created_at":"2025-12-11T23:09:57.756091-05:00","updated_at":"2025-12-11T23:09:57.756091-05:00","labels":["cleanup","type-system"],"dependencies":[{"issue_id":"gneiss-lang-25y","depends_on_id":"gneiss-lang-8ya","type":"blocks","created_at":"2025-12-11T23:10:07.820458-05:00","created_by":"daemon"},{"issue_id":"gneiss-lang-25y","depends_on_id":"gneiss-lang-qkt","type":"parent-child","created_at":"2025-12-12T00:50:17.518393-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-2hq","title":"Phase 4: Type inference with constraints","description":"Extend the Inferencer to:\n\n1. Add `class_env: ClassEnv` and `wanted_preds: Vec\u003cPred\u003e` to Inferencer\n2. Add `register_trait_decl()` - convert Decl::Trait to TraitInfo and store\n3. Add `register_instance_decl()` - convert Decl::Instance to InstanceInfo with overlap checking\n4. Modify `infer_expr()` for ExprKind::Var - check if variable is a trait method\n5. Add pass 2 to `infer_program()` for registering traits/instances before let inference\n6. Modify generalization to include collected predicates in Scheme\n\n**Tests:**\n- `test_trait_method_lookup`\n- `test_method_call_adds_predicate`\n- `test_constraint_satisfied_at_call_site`\n- `test_unsatisfied_constraint_error`","status":"closed","priority":1,"issue_type":"task","assignee":"claude","created_at":"2025-12-10T18:58:45.48729-05:00","updated_at":"2025-12-10T19:03:04.261979-05:00","closed_at":"2025-12-10T19:03:04.261979-05:00","labels":["inference","phase-4"],"dependencies":[{"issue_id":"gneiss-lang-2hq","depends_on_id":"gneiss-lang-k1m","type":"parent-child","created_at":"2025-12-10T18:59:17.74687-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-2rc","title":"Phase 2: Parse trait and instance declarations","description":"Add parser support for typeclass syntax.\n\n**Syntax to support:**\n```gneiss\n-- Trait declaration\ntrait Show a = \n  val show : a -\u003e String \nend\n\n-- Trait with supertrait\ntrait Ord a : Eq = \n  val compare : a -\u003e a -\u003e Int \nend\n\n-- Basic instance\nimpl Show for Int = \n  let show n = int_to_string n \nend\n\n-- Constrained instance\nimpl Show for (List a) where a : Show = \n  let show xs = \"[list]\" \nend\n```\n\n**New parsing functions:**\n- `parse_trait_decl()` \n- `parse_instance_decl()`\n- `parse_constraints()` - for `where a : Show, b : Eq`\n\n**Tests:**\n- `test_parse_trait_decl`\n- `test_parse_instance_decl`\n- `test_parse_constrained_instance`\n- `test_parse_trait_with_supertrait`","status":"closed","priority":1,"issue_type":"task","assignee":"claude","created_at":"2025-12-10T16:33:44.810893-05:00","updated_at":"2025-12-10T16:35:26.566884-05:00","closed_at":"2025-12-10T16:35:26.566884-05:00","labels":["parser","phase-2"],"dependencies":[{"issue_id":"gneiss-lang-2rc","depends_on_id":"gneiss-lang-k1m","type":"parent-child","created_at":"2025-12-10T16:33:57.261966-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-3ik","title":"Add pattern matching exhaustiveness property tests","description":"Add property-based tests for pattern matching exhaustiveness checking.\n\n**Property to test:**\nIf the type checker marks a match expression as exhaustive, evaluation should never fall through (no `MatchFailed` error at runtime).\n\n**Requires:**\n- Generator for ADT definitions\n- Generator for pattern sets covering an ADT\n- Integration with exhaustiveness checker","acceptance_criteria":"- Property test: exhaustive patterns never fail at runtime\n- Property test: non-exhaustive patterns are rejected by type checker","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-09T10:44:09.522184-05:00","updated_at":"2025-12-09T10:44:09.522184-05:00","labels":["pattern-matching","proptest","testing"],"dependencies":[{"issue_id":"gneiss-lang-3ik","depends_on_id":"gneiss-lang-d4s","type":"blocks","created_at":"2025-12-09T10:44:09.523459-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-3iy","title":"Fix shift/reset semantics: wrap continuation invocation in reset","description":"The current delimited continuation implementation has incorrect semantics. When a captured continuation is invoked, it should be wrapped in a fresh `reset` delimiter, but currently it's not.\n\n**Canonical reduction rule:**\n```\nreset E[shift k body] → reset ((λk. body) (λx. reset E[x]))\n                                              ↑↑↑↑↑\n                                        THIS IS THE KEY\n```\n\n**Current behavior (WRONG):** Continuation application splices frames directly without a delimiter - this implements `control/prompt` semantics instead of `shift/reset`.\n\n**Required fix:** Add `cont.push(Frame::Prompt)` before splicing captured frames in continuation application.\n\n**Impact without fix:**\n1. Nested `shift` operations capture incorrect contexts\n2. Multiple continuation invocations may interfere\n3. Programs relying on the delimiter for control flow isolation behave incorrectly\n\n**Location:** `src/eval.rs`, in the `Value::Continuation` match arm\n\n**Reference:** docs/delim_cont_2.md for full analysis","status":"closed","priority":1,"issue_type":"bug","assignee":"claude","created_at":"2025-12-11T19:42:59.373776-05:00","updated_at":"2025-12-11T19:47:02.360628-05:00","closed_at":"2025-12-11T19:47:02.360628-05:00","labels":["bug","continuations","semantics"]}
{"id":"gneiss-lang-3xz","title":"Implement yield points at send/recv","description":"Wire up Channel.send and Channel.recv to actually block the process.\n\n- send blocks until a receiver is ready (rendezvous semantics)\n- recv blocks until a sender is ready\n- Process state transitions: Ready → BlockedSend/BlockedRecv → Ready → Done\n\nThe runtime already has the blocking logic (runtime.rs), but eval.rs doesn't use it correctly. After CPS transform, these ops should capture continuation and return to scheduler instead of continuing execution.\n\nCritical files: src/eval.rs, src/runtime.rs","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-08T19:32:50.977902-05:00","updated_at":"2025-12-08T22:42:34.710486-05:00","closed_at":"2025-12-08T22:42:34.710486-05:00","dependencies":[{"issue_id":"gneiss-lang-3xz","depends_on_id":"gneiss-lang-94p","type":"parent-child","created_at":"2025-12-08T19:32:50.978628-05:00","created_by":"daemon"},{"issue_id":"gneiss-lang-3xz","depends_on_id":"gneiss-lang-q2d","type":"blocks","created_at":"2025-12-08T19:32:50.979246-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-4ya","title":"Add unification idempotence property test","description":"Add property test for unification idempotence: if `unify(a, b)` succeeds, calling `unify(a, b)` again should also succeed and produce the same result.\n\nCurrently we test symmetry and reflexivity but not idempotence. This is important for detecting bugs in the union-find linking.","acceptance_criteria":"- Property test: `unify(a,b); unify(a,b)` succeeds if first unify succeeds\n- After double unification, `a.resolve() == b.resolve()`","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-09T10:44:10.491717-05:00","updated_at":"2025-12-09T10:44:10.491717-05:00","labels":["proptest","testing","type-system"],"dependencies":[{"issue_id":"gneiss-lang-4ya","depends_on_id":"gneiss-lang-d4s","type":"blocks","created_at":"2025-12-09T10:44:10.49267-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-6ci","title":"Local let expressions don't support function syntax or recursion","description":"Local let expressions have two limitations compared to top-level declarations:\n\n1. **No function syntax**: `let f x = ... in body` doesn't parse (only `let x = ... in body` works)\n2. **No recursion**: Even with `let f = fun x -\u003e ... f ... in body`, `f` is not in scope in the RHS\n\nTop-level declarations support both:\n```gneiss\nlet map f lst =       -- function syntax works\n  match lst with\n  | [] -\u003e []\n  | hd :: rest -\u003e f hd :: map f rest  -- recursion works\n```\n\nLocal let should work the same way:\n```gneiss\nlet main () =\n    let loop n = if n == 0 then 0 else n + loop (n - 1) in\n    print (loop 10)\n```\n\nOptions:\n1. Make all local `let` implicitly recursive (like OCaml's `let rec` but without requiring the keyword)\n2. Add `let rec` syntax for explicit recursion\n3. Just support function syntax and make it recursive (current top-level behavior)","notes":"## Implementation Complete\n\n### Changes Made\n\n1. **Parser** (`src/parser.rs:325-375`)\n   - Modified `parse_expr_let` to support function syntax: `let f x y = expr in body`\n   - Desugars to `let f = fun x y -\u003e expr in body`\n   - Collects parameters after the name pattern until `=` is reached\n\n2. **Type Inference** (`src/infer.rs:311-370`)\n   - When pattern is `Var(name)` and value is `Lambda`, adds name to env with preliminary type before inferring lambda\n   - Unifies preliminary type with inferred type for proper recursive type inference\n\n3. **Evaluator** (`src/eval.rs:660-691`)\n   - When binding a variable to a closure, creates recursive closure\n   - New environment includes the binding to itself, enabling self-reference\n\n### Tests Added\n- 6 new tests for local recursive functions:\n  - `test_local_recursive_function` - basic sum recursion\n  - `test_local_recursive_function_factorial` - factorial\n  - `test_local_recursive_function_lambda_form` - explicit lambda form\n  - `test_local_function_non_recursive` - non-recursive still works\n  - `test_local_function_multiple_params` - multiple parameters\n  - `test_nested_local_functions` - nested local functions\n\n### Now Works\n```gneiss\nlet main () =\n    let fact n = if n == 0 then 1 else n * fact (n - 1) in\n    print (fact 5)  -- prints 120\n```","status":"closed","priority":2,"issue_type":"feature","assignee":"claude","created_at":"2025-12-09T13:11:36.516354-05:00","updated_at":"2025-12-09T13:55:23.30422-05:00","closed_at":"2025-12-09T13:55:23.30422-05:00","labels":["parser","syntax"]}
{"id":"gneiss-lang-6dc","title":"Add module AST nodes","description":"Add AST nodes for module system:\n\n```rust\n// Module declaration at top of file\npub struct ModuleDecl {\n    pub name: Ident,\n    pub span: Span,\n}\n\n// Import declaration\npub enum ImportDecl {\n    All { module: Ident, alias: Option\u003cIdent\u003e },\n    Selective { module: Ident, names: Vec\u003cIdent\u003e },\n}\n\n// Or add Private variant to existing Decl\nDecl::Private(Box\u003cDecl\u003e)\n```\n\nConsider how these integrate with existing Program structure.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-11T19:18:57.920337-05:00","updated_at":"2025-12-11T19:18:57.920337-05:00","labels":["ast","modules","phase-3"],"dependencies":[{"issue_id":"gneiss-lang-6dc","depends_on_id":"gneiss-lang-1xe","type":"blocks","created_at":"2025-12-11T19:18:57.921613-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-6gf","title":"Implement proper union-find for type variable unification","description":"The current type variable linking in `types.rs` uses a naive approach that can degrade to O(n) per lookup. We need proper union-find with:\n\n1. **Path compression** in `resolve()` — update intermediate links to point directly to the root\n2. **Union-by-rank** (or union-by-size) — attach smaller trees under larger ones\n\nCurrent code just does:\n```rust\n*var.borrow_mut() = TypeVar::Link(other.clone());\n```\n\nThis can create long chains like: `a -\u003e b -\u003e c -\u003e d -\u003e Int`\n\nWith path compression, after resolving `a`, we'd have: `a -\u003e Int, b -\u003e Int, c -\u003e Int, d -\u003e Int`","design":"## Implementation\n\n### Option A: Path compression only (simpler)\nModify `resolve()` to update links as it traverses:\n\n```rust\npub fn resolve(\u0026self) -\u003e Type {\n    match self {\n        Type::Var(var) =\u003e {\n            let inner = var.borrow().clone();\n            match inner {\n                TypeVar::Link(ty) =\u003e {\n                    let resolved = ty.resolve();\n                    // Path compression: point directly to root\n                    *var.borrow_mut() = TypeVar::Link(resolved.clone());\n                    resolved\n                }\n                _ =\u003e self.clone(),\n            }\n        }\n        _ =\u003e self.clone(),\n    }\n}\n```\n\n### Option B: Full union-find with rank\nAdd rank to `TypeVar::Unbound`:\n```rust\nTypeVar::Unbound { id: TypeVarId, level: u32, rank: u32 }\n```\n\nIn unification, compare ranks and link lower to higher.\n\n### Recommendation\nStart with Option A (path compression only). It's simpler and provides most of the benefit. Union-by-rank matters less when we're unifying type variables with concrete types (which have no rank).\n\n### Considerations\n- Path compression mutates during `resolve()`, which is conceptually a \"read\" operation — this is the standard union-find trade-off\n- Must ensure this doesn't interfere with level tracking for let-polymorphism\n- The `Clone` on `Type` with `Rc\u003cRefCell\u003c...\u003e\u003e` means clones share the same underlying cell, which is correct for union-find","acceptance_criteria":"1. `resolve()` implements path compression\n2. Unification chains are O(α(n)) amortized, not O(n)\n3. All existing tests pass\n4. Level tracking for let-polymorphism still works correctly","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-09T10:34:15.751725-05:00","updated_at":"2025-12-09T10:34:15.751725-05:00","labels":["performance","type-system"]}
{"id":"gneiss-lang-709","title":"Constructor application type checking fails","description":"Constructors with fields fail type checking when applied as functions.\n\nExample that fails:\n```gneiss\ntype Option a = Some a | None\nlet x = Some 5  -- Error: expected Option t3, found ()\n```\n\nRoot cause: `Some 5` parses as `Apply(Constructor{name:\"Some\", args:[]}, Lit(5))`. The type checker sees `Constructor{args:[]}` and expects the args to be filled in, but they're empty, so it fails with a misleading error.\n\nFix: When a constructor has fields but `args` is empty, type it as a curried function type. So `Some : a -\u003e Option a`, then `Apply(Some, 5)` works via normal function application.","status":"closed","priority":1,"issue_type":"bug","assignee":"claude","created_at":"2025-12-09T14:38:47.979217-05:00","updated_at":"2025-12-09T14:50:57.380231-05:00","closed_at":"2025-12-09T14:50:57.380231-05:00","labels":["bug","type-system"]}
{"id":"gneiss-lang-720","title":"Implement error pretty-printing with source context","description":"Create error display that shows source context with caret.\n\nExample output:\n```\nerror[E001]: type mismatch\n --\u003e src/main.gn:15:10\n  |\n15|   let x = foo + \"bar\"\n  |           ^^^^^^^^^^^ expected Int, found String\n```\n\nFeatures:\n- Print source line containing error\n- Show caret/underline pointing to error span\n- Color support (when terminal supports it)\n- Multi-line spans handled gracefully","notes":"Session 2025-12-13: Starting comprehensive error message completion.\\n\\nPhases:\\n1. REPL formatting (in progress)\\n2. LexError spans\\n3. Multi-line span display\\n4. Snapshot tests\\n5. EvalError spans (optional)","status":"closed","priority":1,"issue_type":"task","assignee":"claude","created_at":"2025-12-11T19:18:24.510326-05:00","updated_at":"2025-12-13T12:49:13.892012-05:00","closed_at":"2025-12-13T12:49:13.892012-05:00","labels":["error-handling","phase-2"],"dependencies":[{"issue_id":"gneiss-lang-720","depends_on_id":"gneiss-lang-s9m","type":"blocks","created_at":"2025-12-11T19:18:24.511424-05:00","created_by":"daemon"},{"issue_id":"gneiss-lang-720","depends_on_id":"gneiss-lang-krb","type":"blocks","created_at":"2025-12-11T19:18:24.512116-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-7gf","title":"Channel type inference doesn't constrain element type","description":"Channels are typed as `Channel 'a` (polymorphic) but the type checker doesn't properly unify the type parameter when send/recv are used. This allows type-unsafe programs to pass type checking.\n\nExample that should be rejected but isn't:\n```gneiss\nlet main () =\n    let ch = Channel.new in\n    let _ = spawn (fun () -\u003e Channel.send ch 42) in\n    let _ = spawn (fun () -\u003e Channel.send ch \"oops\") in  -- should error!\n    let x = Channel.recv ch in\n    x + 1  -- runtime type error if string received\n```\n\nThe type checker infers `main : () -\u003e Int` without catching that both Int and String are sent on the same channel.\n\nExpected behavior: Type error at compile time when sending incompatible types on the same channel.\n\nRoot cause: Likely the inference rules for Channel.send and Channel.recv don't properly constrain the channel's type parameter to be consistent across all uses.","design":"Implement ML-style value restriction: only generalize let-bindings where the RHS is a syntactic value (lambda, literal, variable, constructor). Applications like `Channel.new` won't be generalized, so the channel's type variable stays shared across all uses and gets refined/constrained properly.","status":"closed","priority":1,"issue_type":"bug","assignee":"claude","created_at":"2025-12-09T00:12:39.137796-05:00","updated_at":"2025-12-09T00:26:20.278844-05:00","closed_at":"2025-12-09T00:26:20.278844-05:00","labels":["soundness","type-system"]}
{"id":"gneiss-lang-7yx","title":"Parse module declarations and imports","description":"Add parser support for module syntax:\n\n- `module Name` at top of file\n- `import Module` - import all public names\n- `import Module (foo, bar)` - selective import\n- `import Module as M` - qualified import\n- `private let ...` - private declaration\n\nUpdate parse_program() to handle module header and imports before declarations.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-11T19:19:03.130477-05:00","updated_at":"2025-12-11T19:19:03.130477-05:00","labels":["modules","parser","phase-3"],"dependencies":[{"issue_id":"gneiss-lang-7yx","depends_on_id":"gneiss-lang-6dc","type":"blocks","created_at":"2025-12-11T19:19:03.13156-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-803","title":"Implement error reporting framework","description":"Add proper error reporting with source location and context.\n\nCurrently errors show basic messages without line:column information or source context. This epic covers building the infrastructure for better error messages.\n\nKey goals:\n- Convert byte offsets (Span) to line:column positions\n- Print source context with caret pointing to error\n- Consistent error format across ParseError, TypeError, EvalError\n- Optional structured output for tooling","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-11T19:18:07.193539-05:00","updated_at":"2025-12-13T12:51:34.225564-05:00","closed_at":"2025-12-13T12:51:34.225564-05:00","labels":["error-handling","phase-2","ux"]}
{"id":"gneiss-lang-88s","title":"Fix generalize_inner and substitute returning linked type variables","description":"In `generalize_inner` and `substitute`, when a type variable should NOT be generalized/substituted, the code returns `ty.clone()` (the original parameter) instead of the resolved type. This leaks internal linked type variables into type schemes.\n\n**Root cause:** Both functions match on `ty.resolve()` but then return `ty.clone()` in fallback branches, returning the original linked variable instead of the resolved one.\n\n**Fix:** Store resolved type in a variable, match on reference to it, and return `resolved.clone()` instead of `ty.clone()`.\n\nSee `issues/bug4.md` for full analysis.","status":"closed","priority":1,"issue_type":"bug","assignee":"claude","created_at":"2025-12-10T14:44:19.018944-05:00","updated_at":"2025-12-10T14:45:31.095544-05:00","closed_at":"2025-12-10T14:45:31.095544-05:00","labels":["bug","soundness","type-system"]}
{"id":"gneiss-lang-8ya","title":"Full answer-type threading through compound expressions","description":"Current implementation tracks answer types via InferResult, but compound expressions (BinOp, App, etc.) use infer_expr() which discards answer types. This means shift only modifies answer type when directly in reset, not nested.\n\n**Current behavior:**\n```gneiss\nreset (shift (fun k -\u003e \"hello\"))  -- Works: returns String\nreset (1 + shift (fun k -\u003e \"hello\"))  -- Partial: returns Int, not String\n```\n\n**Full threading needed:**\n- BinOp: thread answer types through left and right operands\n- App: implement proper APP rule from Danvy-Filinski\n- If/Match: all branches must have compatible answer types\n- Let: check body's answer types\n\n**References:**\n- docs/delim_cont_types.md (APP rule)\n- src/infer.rs:infer_expr_full (current partial implementation)","status":"closed","priority":3,"issue_type":"task","created_at":"2025-12-11T23:09:57.707742-05:00","updated_at":"2025-12-12T18:06:29.143345-05:00","closed_at":"2025-12-12T18:06:29.143345-05:00","labels":["answer-types","continuations","type-system"],"dependencies":[{"issue_id":"gneiss-lang-8ya","depends_on_id":"gneiss-lang-qkt","type":"parent-child","created_at":"2025-12-12T00:50:15.955716-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-91l","title":"Fix ADT constructor field types + top-level expressions","description":"Two related bugs preventing `examples/adt_fail.gn` from working:\n\n1. **Parse error**: Top-level expressions not allowed - `match` at top level causes \"expected declaration, found Match\"\n\n2. **Type inference bug**: `register_type_decl` ignores actual `TypeExpr` from constructor fields, creating fresh type variables instead. This breaks polymorphic ADT type inference:\n   - WRONG: `unwrap_or : forall a. Option 'a -\u003e Int -\u003e Int`\n   - CORRECT: `unwrap_or : forall a. Option 'a -\u003e 'a -\u003e 'a`\n\nRequires changes to AST, parser, type inference, evaluator, and main.","status":"closed","priority":1,"issue_type":"bug","assignee":"claude","created_at":"2025-12-09T16:12:30.198146-05:00","updated_at":"2025-12-11T10:59:37.804545-05:00","closed_at":"2025-12-11T10:59:37.804545-05:00","labels":["parser","soundness","type-system"]}
{"id":"gneiss-lang-94p","title":"Phase 1: Implement some of the Concurrency Story","description":"Complete Phase 1 of the Gneiss roadmap: get two processes communicating over a channel end-to-end.\n\nGoal: ML-style types + Go-style channels working together.\n\nKey deliverable: Can write and run concurrent Gneiss programs with channels.","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-08T19:32:38.715275-05:00","updated_at":"2025-12-11T19:16:47.665853-05:00","closed_at":"2025-12-11T19:16:47.665853-05:00"}
{"id":"gneiss-lang-9ph","title":"Cleanup + mutual recursion support","description":"Two tasks:\n1. Cleanup from user-defined operators: remove dead code in eval.rs, wire up fixity registration\n2. Add mutual recursion support (let rec ... and ...) needed for pattern_parsers.gn example","status":"closed","priority":1,"issue_type":"feature","assignee":"claude","created_at":"2025-12-13T20:57:24.432698-05:00","updated_at":"2025-12-13T21:42:40.314941-05:00","closed_at":"2025-12-13T21:42:40.314941-05:00","labels":["cleanup","language-feature","recursion"]}
{"id":"gneiss-lang-9q1","title":"Implement property-based tests for delimited continuations","description":"Add comprehensive property-based tests for shift/reset based on docs/prop_for_delim_cont.md and docs/delim_prop.rs.\n\n**Key test categories:**\n\n1. **Algebraic Laws:**\n   - Reset-value identity: `reset v ≡ v`\n   - Reset-reset collapse: `reset (reset e) ≡ reset e`\n   - Shift-discard: `reset (ctx[shift k. v]) ≡ v` (k unused)\n   - Shift-immediate invoke: `reset (shift k. k v) ≡ v`\n   - Continuation extraction: extracted k behaves like context\n\n2. **Critical Semantic Invariants:**\n   - Continuation invocation wrapped in reset (THE critical test)\n   - Multiple invocations independent\n   - Captures exactly to nearest reset\n   - Nested resets delimit independently\n\n3. **Edge Cases:**\n   - Empty context continuation (identity)\n   - Deeply nested shifts\n   - Continuation never called\n   - Continuation called many times\n\n4. **Bug Regression Tests:**\n   - Continuation must wrap reset\n   - Frame order correct\n   - Invocations isolated\n\n**Note on CBV semantics:** The \"critical\" test `reset (shift k1. k1 (shift k2. k2 n)) + 1` expects call-by-name behavior. In Gneiss's strict CBV, the inner shift runs before k1 is invoked, so there's no enclosing reset. We need to adapt these tests or document the CBV limitation.\n\n**Implementation approach:**\n- Create `tests/proptest_continuations.rs`\n- Use string-based eval (like proptest_typeclasses.rs) rather than AST construction\n- Focus on tests that work with CBV semantics","notes":"Session 2025-12-11: Implemented property tests. During implementation, discovered critical bug in frame restoration order - frames were being pushed in wrong order during continuation invocation. Fixed by removing `.rev()` in restore loop. 16 tests pass. 3 tests skipped due to type system limitation (occurs check rejects `reset (shift k -\u003e k)` pattern). Created gneiss-lang-1dd to track type system limitation.","status":"closed","priority":2,"issue_type":"task","assignee":"claude","created_at":"2025-12-11T19:55:53.598498-05:00","updated_at":"2025-12-11T22:25:33.280691-05:00","closed_at":"2025-12-11T20:55:58.048749-05:00","labels":["continuations","proptest","testing"]}
{"id":"gneiss-lang-aam","title":"Phase 6: Dictionary passing runtime","description":"Implement dictionary construction and method dispatch at runtime.\n\n**Changes to eval.rs:**\n\n1. Add `Value::Dict` variant to hold method implementations\n2. Add `build_dict()` to construct dictionaries from resolved instances\n3. Modify `eval_decl()` for `Decl::Trait` and `Decl::Instance` - store instance info\n4. Add method dispatch logic - look up method from dictionary\n5. Store ClassEnv in Interpreter for resolution at runtime\n\n**Value::Dict structure:**\n```rust\nDict {\n    trait_name: String,\n    instance_type: Type,\n    methods: HashMap\u003cString, Value\u003e,\n}\n```\n\n**Tests:**\n- `test_show_int_runtime` - Show 42 produces \"42\"\n- `test_constrained_show_list` - Show [1,2,3] works\n- `test_nested_typeclass` - Show (Some [1,2]) chains correctly","status":"closed","priority":1,"issue_type":"task","assignee":"claude","created_at":"2025-12-10T19:14:33.332006-05:00","updated_at":"2025-12-10T19:30:37.491074-05:00","closed_at":"2025-12-10T19:30:37.491074-05:00","labels":["phase-6","runtime"],"dependencies":[{"issue_id":"gneiss-lang-aam","depends_on_id":"gneiss-lang-k1m","type":"parent-child","created_at":"2025-12-10T19:20:32.376599-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-aj4","title":"Add visibility controls (public/private)","description":"Implement public/private visibility for module exports.\n\nOptions:\n1. Public by default, `private let` for internal\n2. Private by default, explicit `export` list\n3. Both (export list overrides)\n\nImplementation:\n- Track visibility on declarations\n- Filter exports based on visibility\n- Error when importing private names","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-11T19:19:26.525334-05:00","updated_at":"2025-12-11T19:19:26.525334-05:00","labels":["modules","phase-3"],"dependencies":[{"issue_id":"gneiss-lang-aj4","depends_on_id":"gneiss-lang-jiv","type":"blocks","created_at":"2025-12-11T19:19:26.527282-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-axp","title":"Add :env command to REPL","description":"Add `:env` command to show current bindings in the REPL.\n\nOutput format:\n```\ngneiss\u003e :env\nx : Int = 42\ndouble : Int -\u003e Int\nmap : forall a b. (a -\u003e b) -\u003e List a -\u003e List b\n```\n\nOptions:\n- `:env` - show all bindings\n- `:env x` - show specific binding\n- Filter by type (values vs types vs traits)","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-11T19:19:55.540904-05:00","updated_at":"2025-12-11T19:19:55.540904-05:00","labels":["phase-4","repl"],"dependencies":[{"issue_id":"gneiss-lang-axp","depends_on_id":"gneiss-lang-zex","type":"blocks","created_at":"2025-12-11T19:19:55.542108-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-b2n","title":"Design decision: script mode and main function semantics","description":"Researched how other languages handle entry points and concurrency context:\n\n**Current Gneiss model:**\n- With `main`: runs in scheduler, returns Unit, concurrent ops work\n- Without `main`: direct eval, returns Value (testable!), concurrent ops error\n\n**Research findings:**\n- OCaml/SML: No main, top-level evaluated in order\n- Haskell: `main :: IO ()` required, is an action not a function\n- Go: `main()` required, spawned goroutines die when main exits\n- Erlang/Elixir: No main for modules, `main/1` only for escripts\n- Rust+Tokio: `#[tokio::main]` macro wraps async main in runtime\n\n**Key tension:** Go model (main controls lifecycle) vs Erlang model (processes independent)\n\n**Option explored:** Make main return a value (`() -\u003e a` instead of `() -\u003e ()`):\n- Preserves explicit opt-in to concurrency\n- Enables testing concurrent programs\n- Scheduler captures return value of main process\n\n**Compilation target considerations:**\n- Native code: need entry point\n- VM/runtime: could manage process lifecycle independently\n- WASM: need entry point, could export multiple functions\n\n**No implementation this session** - research only for future design decisions.\",\"design\":null,\"acceptance_criteria\":null,\"notes\":null,\"external_ref\":null,\"issue_type\"\u003etask","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-11T18:31:40.703177-05:00","updated_at":"2025-12-11T18:31:40.703177-05:00","labels":["concurrency","design","research"]}
{"id":"gneiss-lang-b8j","title":"Parser precedence: if/else followed by semicolon is mis-parsed","description":"The parser has unexpected precedence for if/else followed by semicolon.\n\n`if cond then a else b; c` parses as `if cond then a else (b; c)` instead of `(if cond then a else b); c`.\n\nWorkaround: Add explicit parentheses around the if expression.\n\nExample from gen.gn:\n```gneiss\n-- Wrong (parses else branch as yield 0; [])\nif n \u003e 0 then yield (n * 2) else (yield 0);\n[]\n\n-- Correct (explicit parens)\n(if n \u003e 0 then yield (n * 2) else yield 0);\n[]\n```\n\nThis is a gotcha when using if expressions in sequences.","notes":"Session 2025-12-13: Fixed by changing parse_expr_if to use parse_expr_let for condition and branches instead of parse_expr. This excludes top-level sequences from branches, matching OCaml/ML precedence where `if c then a else b; c` parses as `(if c then a else b); c`. Sequences in branches now require parentheses. All 224 tests pass.","status":"closed","priority":3,"issue_type":"bug","created_at":"2025-12-12T18:32:46.270947-05:00","updated_at":"2025-12-13T19:27:20.927406-05:00","closed_at":"2025-12-13T19:14:09.775683-05:00","labels":["parser","precedence","ux"]}
{"id":"gneiss-lang-bde","title":"Property tests verify success but not correctness","description":"The typeclass property tests in `tests/proptest_typeclasses.rs` only check that programs succeed (`run_program(\u0026source).is_ok()`), not that they produce correct output.\n\n**Problem:** A typeclass dispatch bug that returns wrong values would pass all tests. We're testing \"doesn't crash\" when we should be testing \"produces expected result\".\n\n**Example:** The test at line 116 (`show_nested_option`) generates `show (Some (Some n))` but only asserts `is_ok()`. If the implementation returned `\"wrong\"` instead of `\"Some(Some(42))\"`, the test would still pass.\n\n**Broader issue:** This pattern of testing-for-success-not-correctness may exist elsewhere. Property-based tests are most valuable when they verify invariants about outputs, not just that code runs without errors.\n\n**Related files:**\n- `tests/proptest_typeclasses.rs` - 20 tests that all use `is_ok()` pattern\n- `tests/properties.rs` - Has `value_matches_type()` helper that actually verifies output types\n\n**Questions to consider:**\n- What should the correct output be for each typeclass test case?\n- Should we verify exact string output, or just structural properties?\n- How do we balance test complexity with coverage?","notes":"Session 2025-12-11: COMPLETE. Changed run_program() to return Result\u003cValue, String\u003e. Updated all 20 proptest tests and 8 regression tests to verify actual string values using matches!(result, Value::String(ref s) if s == expected). Removed unused expect_string() helper. All 141 tests pass.","status":"closed","priority":2,"issue_type":"bug","assignee":"claude","created_at":"2025-12-11T10:57:59.371712-05:00","updated_at":"2025-12-11T18:31:19.992452-05:00","closed_at":"2025-12-11T13:25:59.657426-05:00","labels":["proptest","testing","typeclasses"]}
{"id":"gneiss-lang-bpl","title":"Implement delimited continuations (reset/shift)","description":"Implement delimited continuations following docs/delim_cont.md specification.\n\nThis involves changes to:\n1. Lexer - add Reset and Shift tokens\n2. AST - add Reset and Shift variants to ExprKind\n3. Parser - parse reset/shift expressions\n4. Type inference - type reset and shift\n5. Evaluator - implement Prompt frame, Continuation value, and continuation capture/application\n\nSee docs/delim_cont.md for full specification.","notes":"## Implementation Complete\n\n### Changes Made\n\n1. **Lexer** (`src/lexer.rs`)\n   - Added `Reset` and `Shift` tokens\n   - Added keyword recognition for `reset` and `shift`\n\n2. **AST** (`src/ast.rs`)\n   - Added `ExprKind::Reset(Rc\u003cExpr\u003e)` variant\n   - Added `ExprKind::Shift { param: Pattern, body: Rc\u003cExpr\u003e }` variant\n\n3. **Parser** (`src/parser.rs`)\n   - Added `Reset` and `Shift` to `is_atom_start`\n   - Added parsing for `reset expr` and `shift (fun k -\u003e body)`\n\n4. **Evaluator** (`src/eval.rs`)\n   - Added `Frame::Prompt` for delimiting continuations\n   - Added `Value::Continuation { frames: Vec\u003cFrame\u003e }` for captured continuations\n   - `reset` pushes Prompt frame and evaluates body\n   - `shift` captures frames up to Prompt, binds continuation to parameter, evaluates body\n   - `Prompt` frame passes value through on completion\n   - Continuation application splices frames back and passes argument as result\n\n5. **Type Inference** (`src/infer.rs`)\n   - `reset e : a` where `e : a` (passthrough)\n   - `shift` uses simplified typing: `k : a -\u003e a, body : a, result : a`\n   - Full answer-type polymorphism deferred\n\n6. **Main** (`src/main.rs`)\n   - Added `Continuation` case to `print_value`\n\n### Tests Added\n- 13 new eval tests for delimited continuations\n- 3 new type inference tests\n\n### Examples Created\n- `examples/continuations_basic.gn` - basic reset/shift usage\n- `examples/continuations_escape.gn` - early exit pattern\n- `examples/continuations_collect.gn` - multiple invocations\n\n### Limitations\n- Simplified typing prevents some valid programs (e.g., collecting into list when inner computation returns different type)\n- Full answer-type polymorphism can be added later for more expressive types","status":"closed","priority":1,"issue_type":"feature","assignee":"claude","created_at":"2025-12-09T13:06:08.493189-05:00","updated_at":"2025-12-09T13:12:39.787255-05:00","closed_at":"2025-12-09T13:12:39.787255-05:00","labels":["concurrency","control-flow"]}
{"id":"gneiss-lang-ciu","title":"Fix top-level let parsing: distinguish declarations from let-expressions","description":"Two issues with top-level `let` parsing:\n\n**Issue 1**: `let var = \"string\" in var` fails to parse at top-level\n- Parser sees `Let` → immediately assumes declaration\n- `in var` left as unexpected tokens → parse error\n- But this is a valid let-expression!\n\n**Issue 2**: No way to terminate declarations explicitly\n- `let var = \"string\"` followed by `var` silently mis-parses as `(\"string\" var)`\n\n**Solution**:\n1. Add `;;` token for explicit termination\n2. Create unified `parse_let_item()` that checks for `in` after `let name = expr`\n3. If `in` → let-expression (Item::Expr)\n4. Otherwise → declaration (Item::Decl)","notes":"Session 2025-12-11: COMPLETE. Added DoubleSemi token to lexer. Created unified parse_let_item() that checks for 'in' keyword to distinguish let-expressions from declarations. Added 4 new parser tests. All 141 tests pass.","status":"closed","priority":3,"issue_type":"feature","assignee":"claude","created_at":"2025-12-10T16:09:41.890304-05:00","updated_at":"2025-12-11T18:31:20.094965-05:00","closed_at":"2025-12-11T12:07:47.887245-05:00","labels":["parser","ux"]}
{"id":"gneiss-lang-cqa","title":"Add :load command to REPL","description":"Add `:load \u003cfilename\u003e` command to load .gn files into the REPL.\n\nBehavior:\n- Parse and type-check the file\n- Add all declarations to REPL environment\n- Report errors if any\n- Can load multiple files\n\nExample:\n```\ngneiss\u003e :load examples/list.gn\nLoaded 5 declarations from examples/list.gn\ngneiss\u003e map double [1,2,3]\n[2, 4, 6]\n```","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-11T19:19:49.920006-05:00","updated_at":"2025-12-11T19:19:49.920006-05:00","labels":["phase-4","repl"],"dependencies":[{"issue_id":"gneiss-lang-cqa","depends_on_id":"gneiss-lang-zex","type":"blocks","created_at":"2025-12-11T19:19:49.921897-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-d12","title":"Add circular dependency detection","description":"Detect and report circular imports.\n\nExample:\n- A imports B\n- B imports C  \n- C imports A  \u003c- error!\n\nImplementation:\n- Track \"currently loading\" modules during resolution\n- If we try to load a module that's already loading, error\n- Provide helpful error showing the cycle path","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-11T19:19:20.336705-05:00","updated_at":"2025-12-11T19:19:20.336705-05:00","labels":["modules","phase-3"],"dependencies":[{"issue_id":"gneiss-lang-d12","depends_on_id":"gneiss-lang-jiv","type":"blocks","created_at":"2025-12-11T19:19:20.340017-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-d4s","title":"Implement property-based testing for type system soundness","description":"Add comprehensive property-based testing using `proptest` or `quickcheck` to ensure type system soundness and catch regressions. The Gneiss type system implements Hindley-Milner inference with let-polymorphism, mutable reference-based type variable linking (not yet a proper union-find), and support for ADTs, channels, and processes. Property-based testing is essential for:\n\n1. **Catching edge cases** in unification, occurs check, and level updates\n2. **Ensuring type safety invariants** hold across random well-typed programs\n3. **Finding soundness bugs** before they manifest in user code\n4. **Regression testing** as the type system evolves\n\nThis is critical infrastructure for maintaining soundness while iterating.\n\nNote: The current implementation uses `Rc\u003cRefCell\u003cTypeVar\u003e\u003e` with a `Link` variant for unification, but lacks path compression and union-by-rank (see gneiss-lang-6gf).","design":"## Implementation Strategy\n\n### Phase 1: Infrastructure Setup\n- Add `proptest` as a dev-dependency (preferred over quickcheck for better shrinking)\n- Create `tests/properties/` directory structure for property tests\n- Implement `Arbitrary` generators for core types\n\n### Phase 2: AST Generators\nCreate generators for well-formed AST nodes:\n```rust\n// Generate arbitrary expressions\nprop_compose! {\n    fn arb_literal()(kind in prop_oneof![\n        Just(LitKind::Int(42)),\n        any::\u003ci64\u003e().prop_map(LitKind::Int),\n        any::\u003cbool\u003e().prop_map(LitKind::Bool),\n        // ...\n    ]) -\u003e Expr { Expr::Literal(kind) }\n}\n\n// Generate well-scoped expressions (respecting variable binding)\nfn arb_expr_with_env(env: Vec\u003cString\u003e, depth: usize) -\u003e impl Strategy\u003cValue = Expr\u003e\n```\n\nKey insight: Generate *well-scoped* expressions to avoid trivial \"unbound variable\" failures.\n\n### Phase 3: Type Generators\n```rust\n// Generate arbitrary monomorphic types\nfn arb_mono_type(depth: usize) -\u003e impl Strategy\u003cValue = Type\u003e\n\n// Generate polymorphic type schemes\nfn arb_scheme() -\u003e impl Strategy\u003cValue = Scheme\u003e\n```\n\n### Phase 4: Core Soundness Properties\n\n**Property 1: Unification is symmetric**\n```rust\nproptest! {\n    fn unify_symmetric(t1: Type, t2: Type) {\n        let r1 = fresh_inferencer().unify(\u0026t1, \u0026t2);\n        let r2 = fresh_inferencer().unify(\u0026t2, \u0026t1);\n        assert_eq!(r1.is_ok(), r2.is_ok());\n    }\n}\n```\n\n**Property 2: Unification is idempotent**\n```rust\nproptest! {\n    fn unify_idempotent(t1: Type, t2: Type) {\n        let mut inf = fresh_inferencer();\n        if inf.unify(\u0026t1, \u0026t2).is_ok() {\n            // Unifying again should succeed and produce same result\n            assert!(inf.unify(\u0026t1, \u0026t2).is_ok());\n            assert_eq!(t1.resolve(), t2.resolve());\n        }\n    }\n}\n```\n\n**Property 3: Occurs check prevents infinite types**\n```rust\nproptest! {\n    fn occurs_check_sound(var_id: TypeVarId) {\n        let var = Type::new_var(var_id, 0);\n        let cyclic = Type::Arrow(Rc::new(var.clone()), Rc::new(var.clone()));\n        // Should detect the cycle\n        assert!(var.occurs(var_id) || cyclic.occurs(var_id));\n    }\n}\n```\n\n**Property 4: Type preservation (the big one)**\n```rust\nproptest! {\n    fn type_preservation(expr in arb_well_typed_expr()) {\n        let mut inf = Inferencer::new();\n        let ty = inf.infer(\u0026TypeEnv::new(), \u0026expr).unwrap();\n        let result = eval(\u0026Env::new(), \u0026expr);\n        // If eval succeeds, result should have inferred type\n        if let Ok(val) = result {\n            assert!(value_has_type(\u0026val, \u0026ty));\n        }\n        // If eval fails, it should be a runtime error, not type error\n    }\n}\n```\n\n**Property 5: Progress (well-typed programs don't get stuck)**\n```rust\nproptest! {\n    fn progress(expr in arb_well_typed_expr()) {\n        let result = eval(\u0026Env::new(), \u0026expr);\n        // Should either produce a value or a well-defined runtime error\n        // Should NOT panic or produce undefined behavior\n    }\n}\n```\n\n**Property 6: Let-polymorphism correctness**\n```rust\nproptest! {\n    fn let_poly_instantiation(body in arb_expr()) {\n        // let id = fun x -\u003e x in (id 1, id true)\n        // Should type-check with id : forall a. a -\u003e a\n        let id_def = /* ... */;\n        let usage = /* ... */;\n        // Both uses should succeed with different instantiations\n    }\n}\n```\n\n**Property 7: Generalization respects levels**\n```rust\nproptest! {\n    fn generalization_sound(expr in arb_let_expr()) {\n        // Type variables that escape their scope should not be generalized\n        let mut inf = Inferencer::new();\n        let result = inf.infer(\u0026env, \u0026expr);\n        if let Ok(ty) = result {\n            // Check that free type vars in ty are not generic\n        }\n    }\n}\n```\n\n### Phase 5: Pattern Matching Properties\n\n**Property 8: Exhaustiveness soundness**\n```rust\nproptest! {\n    fn exhaustive_patterns_complete(\n        adt_def in arb_adt_definition(),\n        patterns in arb_patterns_for_adt(\u0026adt_def)\n    ) {\n        // If patterns marked exhaustive, evaluation should never fall through\n    }\n}\n```\n\n### Phase 6: Concurrency Properties\n\n**Property 9: Channel type safety**\n```rust\nproptest! {\n    fn channel_types_preserved(msg_type: Type) {\n        // Channel\u003cInt\u003e should only accept/produce Int values\n    }\n}\n```\n\n### Phase 7: Fuzzing Integration\n- Use `cargo fuzz` for parser fuzzing\n- AFL/libfuzzer for finding crashes in type inference\n- Corpus seeding from example programs\n\n## Test Organization\n\n```\ntests/\n├── properties/\n│   ├── mod.rs\n│   ├── generators.rs      # Arbitrary impls\n│   ├── unification.rs     # Unification properties\n│   ├── inference.rs       # Type inference properties\n│   ├── preservation.rs    # Type preservation\n│   └── concurrency.rs     # Channel/spawn properties\n└── integration/\n    └── soundness.rs       # End-to-end property tests\n```\n\n## Complexity Budget\n- Start with simple generators, grow complexity incrementally\n- Use `prop_filter` sparingly (shrinking works poorly with heavy filtering)\n- Generate well-formed inputs rather than filtering malformed ones","acceptance_criteria":"1. **Dependencies added**: `proptest` in `Cargo.toml` dev-dependencies\n2. **Generators implemented**: \n   - `Arbitrary` for `Type`, `Expr`, `Pattern`, `Scheme`\n   - Well-scoped expression generator respecting variable bindings\n3. **Core properties tested**:\n   - [ ] Unification symmetry and idempotence\n   - [ ] Occurs check prevents infinite types\n   - [ ] Type preservation: well-typed programs evaluate to correctly-typed values\n   - [ ] Progress: well-typed programs don't get stuck\n   - [ ] Let-polymorphism instantiation works correctly\n   - [ ] Generalization respects escape analysis (levels)\n4. **Pattern matching properties**:\n   - [ ] Exhaustiveness checking is sound\n5. **Concurrency properties**:\n   - [ ] Channel types are preserved through send/recv\n6. **CI integration**: Property tests run in `cargo test`\n7. **Documentation**: Properties documented with their theoretical basis\n8. **Shrinking works**: Failures shrink to minimal counterexamples","notes":"## Implementation Progress\n\n### Completed\n- Added `proptest = \"1.5\"` as dev-dependency\n- Created `tests/properties.rs` with comprehensive property tests\n- Exposed `Inferencer::unify_types()` for testing\n\n### Properties Implemented\n1. **Unification properties** (3 tests)\n   - `unify_symmetric` - unify(a,b) succeeds iff unify(b,a) succeeds\n   - `unify_reflexive` - unify(a,a) always succeeds\n   - `unify_produces_equal_types` - after unification, types resolve to same\n\n2. **Occurs check properties** (2 tests)\n   - `occurs_check_detects_self_reference` - variable occurs in itself\n   - `occurs_check_negative` - variable doesn't occur in unrelated ground types\n\n3. **Type inference properties** (2 tests)\n   - `inference_deterministic` - same source yields same type\n   - `inference_does_not_panic` - inference never panics\n\n4. **Soundness properties** (2 tests)\n   - `type_preservation` - values match their inferred types\n   - `progress` - well-typed programs don't panic/get stuck\n\n5. **Let-polymorphism properties** (2 tests)\n   - `identity_is_polymorphic` - `let id = fun x -\u003e x` works at multiple types\n   - `const_is_polymorphic` - `let const = fun x -\u003e fun y -\u003e x` is polymorphic\n\n6. **Regression tests** (4 tests)\n   - `test_occurs_check_prevents_infinite_type`\n   - `test_let_polymorphism_basic`\n   - `test_value_restriction`\n   - `test_nested_let_polymorphism`\n\n### Bugs Found\n- Integer overflow in eval.rs:791 (filed as gneiss-lang-dwx)\n\n### Generators Available (for future expansion)\n- `arb_ground_type(depth)` - generates monomorphic types\n- `arb_type_with_vars(depth)` - types with fresh type variables\n- `arb_well_typed_source()` - valid Gneiss source strings\n- `arb_expr(env, depth)` - well-scoped AST expressions (reserved)","status":"closed","priority":1,"issue_type":"feature","assignee":"claude","created_at":"2025-12-09T10:31:13.009366-05:00","updated_at":"2025-12-09T10:47:38.278198-05:00","closed_at":"2025-12-09T10:47:38.278198-05:00","labels":["infrastructure","soundness","testing","type-system"],"dependencies":[{"issue_id":"gneiss-lang-d4s","depends_on_id":"gneiss-lang-6gf","type":"related","created_at":"2025-12-09T10:34:55.793226-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-drf","title":"Implement module system","description":"Add module system with explicit module declarations, imports, and exports.\n\nSyntax:\n```gneiss\nmodule List\n\nimport Other\nimport Other (foo, bar)  -- selective\nimport Other as O        -- qualified\n\nlet map f xs = ...\nprivate let helper x = ...\n```\n\nKey features:\n- Explicit `module ModuleName` at file top\n- Import with selective and qualified forms\n- Public/private visibility\n- Multi-file build support\n- Circular dependency detection","status":"open","priority":2,"issue_type":"epic","created_at":"2025-12-11T19:18:46.381772-05:00","updated_at":"2025-12-11T19:18:46.381772-05:00","labels":["modules","phase-3"]}
{"id":"gneiss-lang-dwx","title":"Integer arithmetic overflow in evaluator","description":"Property-based testing discovered that integer addition can panic with overflow when adding large i64 values.\n\n**Minimal failing case:**\n```\nlet x = 1913824111850683246 in x + 7309547925004092562\n```\nor\n```\n-3258846342380324963 + -5964525694474450846\n```\n\n**Location:** `src/eval.rs:791`\n\n**Impact:** Well-typed programs can panic, violating the progress property.","design":"Options:\n1. Use `checked_add` and return a runtime error on overflow\n2. Use `wrapping_add` for C-like wraparound semantics\n3. Use `saturating_add` to clamp to min/max values\n\nRecommendation: Use `checked_add` and return `EvalError::RuntimeError(\"integer overflow\")` - this is the most principled approach for a language that claims static typing prevents runtime errors.","acceptance_criteria":"- All integer arithmetic operations use checked variants\n- Overflow produces a well-defined `EvalError`, not a panic\n- Property test `progress` passes","status":"open","priority":2,"issue_type":"bug","created_at":"2025-12-09T10:38:55.782392-05:00","updated_at":"2025-12-09T10:38:55.782392-05:00","labels":["bug","found-by-proptest","runtime"]}
{"id":"gneiss-lang-ebe","title":"Match arm body doesn't accept let expressions","description":"The parser fails when a match arm body is a let expression:\n\n```\nmatch x with\n| Foo y -\u003e let z = 1 in z   -- Parse error: expecting expression but found Let\n```\n\nThe RHS of match arrows should parse as any expression, including let expressions.\n\nFound while testing examples/cont/pattern_effect_handlers.gn","status":"open","priority":2,"issue_type":"bug","created_at":"2025-12-13T13:31:19.283088-05:00","updated_at":"2025-12-13T13:31:19.283088-05:00","labels":["match","parser"]}
{"id":"gneiss-lang-fo5","title":"Type::List vs Type::Constructor {\"List\"} don't unify","description":"When `List Int` appears in a type declaration (e.g., `type NondetOp = Choose (List Int)`), it becomes `Type::Constructor { name: \"List\", args: [Int] }`.\n\nBut list literals `[]` and `[1,2,3]` create `Type::List(elem_type)`.\n\nThese two representations don't unify, causing confusing type errors like:\n```\nExpected: List Int\nBut found: [t64]\n```\n\nExample that fails:\n```gneiss\ntype MyOp =\n    | DoIt (List Int)\n    | Skip\n\nlet process op =\n    match op with\n    | DoIt xs -\u003e xs   -- xs : List Int (from Constructor)\n    | Skip -\u003e []      -- [] : [t] (from Type::List) -- ERROR!\n```\n\nThe issue is that `List` in user code creates `Type::Constructor` but list expressions create `Type::List`. These need to unify.\n\nOptions:\n1. Normalize `List` in type expressions to `Type::List` (but conflicts with user-defined `List` types)\n2. Add unification case for `(Type::Constructor { name: \"List\", args }, Type::List(elem))` \n3. Eliminate `Type::List` and always use `Type::Constructor { name: \"List\" }`","notes":"Session 2025-12-13: Fixed by removing Type::List variant entirely. Canonicalized all list representations to Type::Constructor { name: \"List\" }. Added Type::list() helper. Updated ~20 locations across types.rs, infer.rs, parser.rs, ast.rs, eval.rs, tests/properties.rs. Added [a] type annotation syntax and val declarations. Display special-cases List to show as [Int]. All 224 tests pass.","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-13T18:27:06.063058-05:00","updated_at":"2025-12-13T19:27:20.880948-05:00","closed_at":"2025-12-13T19:14:11.874934-05:00","labels":["lists","type-system"]}
{"id":"gneiss-lang-g5a","title":"Add channel type safety property tests","description":"Add property-based tests for channel type safety in concurrent programs.\n\n**Properties to test:**\n1. `Channel\u003cInt\u003e` only accepts/produces `Int` values\n2. Type mismatches on send/recv are caught at type-check time\n3. The value restriction prevents unsound polymorphic channels\n\n**Requires:**\n- Generator for concurrent program fragments\n- Way to test channel operations without deadlocking","acceptance_criteria":"- Property test: channel types are preserved through send/recv\n- Property test: polymorphic channel bug is prevented by value restriction","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-09T10:44:09.812152-05:00","updated_at":"2025-12-09T10:44:09.812152-05:00","labels":["concurrency","proptest","testing"],"dependencies":[{"issue_id":"gneiss-lang-g5a","depends_on_id":"gneiss-lang-d4s","type":"blocks","created_at":"2025-12-09T10:44:09.813385-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-jiv","title":"Implement import resolution and name binding","description":"Resolve imports and bind names into scope.\n\nFor each import:\n1. Load and parse the target module (if not cached)\n2. Type check the target module (if not cached)\n3. Extract public names/types\n4. Bind into current module's scope\n\nHandle:\n- Name conflicts between imports\n- Qualified vs unqualified names\n- Type imports vs value imports","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-11T19:19:15.202494-05:00","updated_at":"2025-12-11T19:19:15.202494-05:00","labels":["modules","phase-3"],"dependencies":[{"issue_id":"gneiss-lang-jiv","depends_on_id":"gneiss-lang-w3i","type":"blocks","created_at":"2025-12-11T19:19:15.203599-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-jkr","title":"Phase 5: Instance resolution algorithm","description":"Implement the instance resolution algorithm that finds which instance satisfies a predicate.\n\n**Core functions to add to types.rs or infer.rs:**\n\n1. `match_type(pattern: \u0026Type, target: \u0026Type) -\u003e Option\u003cSubstitution\u003e` - One-way matching for instance selection\n2. `resolve_pred(pred: \u0026Pred) -\u003e Result\u003cResolution, TypeError\u003e` - Find instance matching a predicate\n3. `resolve_all(preds: \u0026[Pred]) -\u003e Result\u003cVec\u003cResolution\u003e, TypeError\u003e` - Resolve all predicates including sub-predicates\n4. `entail(given: \u0026[Pred], goal: \u0026Pred) -\u003e bool` - Check if given predicates entail a goal\n\n**Resolution struct:**\n```rust\nstruct Resolution {\n    instance_idx: usize,\n    subst: HashMap\u003cTypeVarId, Type\u003e,\n    sub_preds: Vec\u003cPred\u003e,\n}\n```\n\n**Tests:**\n- `test_match_type_exact` - Int matches Int\n- `test_match_type_variable` - 'a matches Int with substitution\n- `test_match_type_constructor` - List 'a matches List Int\n- `test_resolve_basic_instance` - Resolve Show Int\n- `test_resolve_constrained_instance` - Resolve Show (List Int) with sub-predicates","status":"closed","priority":1,"issue_type":"task","assignee":"claude","created_at":"2025-12-10T19:03:15.800686-05:00","updated_at":"2025-12-10T19:14:21.832567-05:00","closed_at":"2025-12-10T19:14:21.832567-05:00","labels":["phase-5","resolution"],"dependencies":[{"issue_id":"gneiss-lang-jkr","depends_on_id":"gneiss-lang-k1m","type":"parent-child","created_at":"2025-12-10T19:03:22.928555-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-k1m","title":"Implement typeclasses for Gneiss","description":"Add typeclass support to Gneiss using dictionary passing. Follows the design in `docs/typeclasses_plan.md` and `docs/typeclasses_technical.md`.\n\nKey features:\n- Single-parameter typeclasses (no HKT)\n- Constrained instances (`impl Show for (List a) where a : Show`)\n- Supertraits (`trait Ord a : Eq`)\n- Dictionary passing at runtime\n\nImplementation phases:\n1. Lexer \u0026 AST - tokens and declarations\n2. Parser - parse trait/instance syntax\n3. Type system - Pred, ClassEnv, modify Scheme\n4. Type inference - constraint collection\n5. Instance resolution - matching algorithm\n6. Dictionary passing - runtime evaluation\n\n~1400 lines estimated.","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-10T16:31:27.384781-05:00","updated_at":"2025-12-10T19:30:48.326316-05:00","closed_at":"2025-12-10T19:30:48.326316-05:00","labels":["feature","type-system"]}
{"id":"gneiss-lang-krb","title":"Create source location infrastructure","description":"Create infrastructure to store source text and compute positions for error reporting.\n\nNeeds:\n- Structure to hold source text alongside file path\n- Method to extract line of source at given position\n- Integration with error types to carry source context\n\nThis enables printing source context with errors.","notes":"Starting implementation of error formatting infrastructure with Elm-inspired design.","status":"closed","priority":1,"issue_type":"task","assignee":"claude","created_at":"2025-12-11T19:18:17.615519-05:00","updated_at":"2025-12-13T12:12:09.846619-05:00","closed_at":"2025-12-13T12:12:09.846619-05:00","labels":["error-handling","phase-2"],"dependencies":[{"issue_id":"gneiss-lang-krb","depends_on_id":"gneiss-lang-803","type":"blocks","created_at":"2025-12-11T19:18:17.61658-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-m3p","title":"Integration tests: producer-consumer, multiple channels","description":"Write integration tests for more complex concurrency patterns.\n\nTests to add:\n1. Producer-consumer: one process generates values, another consumes them\n2. Multiple channels: processes communicating over several channels\n3. Select usage: process waiting on multiple channels\n\nThese tests validate that the concurrency system works for real-world patterns, not just simple ping-pong.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-08T19:33:14.335458-05:00","updated_at":"2025-12-08T19:33:14.335458-05:00","dependencies":[{"issue_id":"gneiss-lang-m3p","depends_on_id":"gneiss-lang-94p","type":"parent-child","created_at":"2025-12-08T19:33:14.336128-05:00","created_by":"daemon"},{"issue_id":"gneiss-lang-m3p","depends_on_id":"gneiss-lang-mzz","type":"blocks","created_at":"2025-12-08T19:33:14.336766-05:00","created_by":"daemon"},{"issue_id":"gneiss-lang-m3p","depends_on_id":"gneiss-lang-yga","type":"blocks","created_at":"2025-12-08T19:33:14.337272-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-mql","title":"Implement multi-line input mode in REPL","description":"Allow multi-line input in the REPL.\n\nOptions:\n1. Detect incomplete expressions (open paren, unclosed let..in)\n2. Explicit continuation character (e.g., backslash at end of line)\n3. Special command to enter multi-line mode\n\nShow continuation prompt (e.g., \"... \") when in multi-line mode.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-11T19:19:44.279496-05:00","updated_at":"2025-12-11T19:19:44.279496-05:00","labels":["phase-4","repl"],"dependencies":[{"issue_id":"gneiss-lang-mql","depends_on_id":"gneiss-lang-x79","type":"blocks","created_at":"2025-12-11T19:19:44.281403-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-mzz","title":"Test: ping-pong between two processes","description":"Integration test proving two processes can communicate over a channel.\n\nTest case:\n1. Main spawns two processes\n2. Process A sends a value on channel\n3. Process B receives the value\n4. Both processes complete successfully\n\nThis validates the entire concurrency stack: spawn, channels, blocking, scheduler resumption.\n\nFile: examples/channel.gn already exists but doesn't work yet.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-08T19:33:02.550929-05:00","updated_at":"2025-12-09T00:15:05.943437-05:00","closed_at":"2025-12-09T00:15:05.943437-05:00","dependencies":[{"issue_id":"gneiss-lang-mzz","depends_on_id":"gneiss-lang-94p","type":"parent-child","created_at":"2025-12-08T19:33:02.55194-05:00","created_by":"daemon"},{"issue_id":"gneiss-lang-mzz","depends_on_id":"gneiss-lang-z43","type":"blocks","created_at":"2025-12-08T19:33:02.552851-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-n4n","title":"Update ParseError to use error framework","description":"Update ParseError to carry span information and use the new error reporting framework.\n\nCurrently ParseError variants don't include spans. Need to:\n- Add span field to ParseError variants\n- Carry span through parser\n- Use new pretty-printing for display","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-11T19:18:29.653543-05:00","updated_at":"2025-12-13T12:17:32.672625-05:00","closed_at":"2025-12-13T12:17:32.672625-05:00","labels":["error-handling","parser","phase-2"],"dependencies":[{"issue_id":"gneiss-lang-n4n","depends_on_id":"gneiss-lang-720","type":"blocks","created_at":"2025-12-11T19:18:29.654908-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-oa6","title":"Update TypeError to use error framework","description":"Update TypeError to carry span information and use the new error reporting framework.\n\nType errors are the most complex - need to show:\n- Location where mismatch was detected\n- Both expected and found types\n- Potentially trace back to where types were inferred\n\nStart with basic span inclusion, can add inference traces later.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-11T19:18:34.662841-05:00","updated_at":"2025-12-13T12:17:43.983525-05:00","closed_at":"2025-12-13T12:17:43.983525-05:00","labels":["error-handling","phase-2","type-system"],"dependencies":[{"issue_id":"gneiss-lang-oa6","depends_on_id":"gneiss-lang-720","type":"blocks","created_at":"2025-12-11T19:18:34.663995-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-p9b","title":"Type error in effect handlers example: () vs () mismatch","description":"After fixing the parser to handle nested constructor patterns, the effect handlers example (`examples/cont/pattern_effect_handlers.gn`) now parses but fails with a confusing type error:\n\n```\n-- TYPE ERROR ----------------------------------------------\n\nI found a type mismatch.\n\n  I expected:  ()\n  But found:   ()\n```\n\nThe error message shows the same type on both sides, which indicates either:\n1. A bug in type error reporting (not showing the actual types)\n2. An issue with type inference for complex continuation types in effect handlers\n\nThis blocks validation of the effect handler patterns.\n\nRelated to gneiss-lang-ebe (match arm body limitation) which required workarounds in the example.","notes":"Session 2025-12-13:\nFIXED: Type::Unit vs Type::Tuple(vec![]) now unify correctly.\n- Added normalization in infer.rs:632 and infer.rs:1136\n- Empty tuples become Type::Unit at construction\n\nALSO FIXED (example file pattern_effect_handlers.gn):\n- Changed ExnEff from 1 to 2 type params\n- Simplified throw_exn to use continuation directly\n\nNOT COMPLETE: The full effect handlers example still doesn't run due to gneiss-lang-fo5 (List type issue).\n\nTests: All 20 pass, snapshot updated.","status":"closed","priority":2,"issue_type":"bug","assignee":"claude","created_at":"2025-12-13T13:35:06.427762-05:00","updated_at":"2025-12-13T18:31:47.912581-05:00","closed_at":"2025-12-13T18:27:05.977172-05:00","labels":["effects","error-messages","type-inference"]}
{"id":"gneiss-lang-pah","title":"Integrate dictionary passing into expression evaluation","description":"The dictionary passing infrastructure exists but isn't connected to the evaluation loop.\n\nCurrently `show 42` fails at runtime because:\n1. `show` is looked up as a variable and not found\n2. We need to detect trait method calls and build dictionaries dynamically\n\n**Solution:** When evaluating a function application where the function is a trait method:\n1. Evaluate the argument to get its runtime value\n2. Use `Value::to_type()` to get the runtime type\n3. Build a dictionary for that type using `build_dict()`\n4. Look up the method in the dictionary and call it\n\nThis requires modifying the stepping evaluator to handle trait method dispatch.","status":"closed","priority":1,"issue_type":"task","assignee":"claude","created_at":"2025-12-10T19:33:29.655816-05:00","updated_at":"2025-12-10T20:13:20.532053-05:00","closed_at":"2025-12-10T20:13:20.532053-05:00","labels":["phase-6b","runtime"]}
{"id":"gneiss-lang-pju","title":"Channel operations panic without main function","description":"Using `Channel.send`, `Channel.recv`, or `select` without a `main` function causes a panic with \"recv called outside of process\" instead of a proper error.\n\n**Root cause:** Channel operations require a process context (tracked by `runtime.current_pid()`), which only exists when code runs inside the scheduler via `main`.\n\n**Fix:** Added checks in the evaluator before calling runtime methods. Now returns `EvalError::RuntimeError` with a helpful message like \"Channel.recv requires a process context (define a main function)\".","notes":"Session 2025-12-11: COMPLETE. Added process context checks in eval.rs at Frame::SendVal, Frame::Recv, and Frame::SelectReady (before block_on_select). Now returns EvalError::RuntimeError with helpful message instead of panicking. All 141 tests pass.","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-11T14:36:12.668208-05:00","updated_at":"2025-12-11T18:31:20.041156-05:00","closed_at":"2025-12-11T14:37:58.795633-05:00","labels":["concurrency","error-handling","runtime"]}
{"id":"gneiss-lang-q2d","title":"CPS transform the interpreter","description":"Convert eval to continuation-passing style so processes can suspend and resume.\n\nCurrently eval is synchronous - when a process hits Channel.recv, it returns immediately with Unit instead of suspending. CPS will allow blocking operations to capture \"what to do next\" and return control to the scheduler.\n\nKey changes:\n- eval takes a continuation parameter\n- Blocking ops (send/recv) capture continuation and return to scheduler\n- Non-blocking ops invoke continuation directly\n\nCritical file: src/eval.rs","notes":"Implemented defunctionalized CPS interpreter:\n\n- Added Frame enum representing continuation frames (stack-based)\n- Added Cont struct as the continuation stack  \n- Added State enum (Eval/Apply modes)\n- Added StepResult enum for step outcomes (Continue/Done/Blocked/Error)\n- Converted eval to step-based machine with step_eval and step_apply\n- All existing tests pass (21/21)\n- REPL works correctly\n\nThe interpreter now supports suspension via StepResult::Blocked, which will be used for channel operations. The continuation stack (Cont) can be saved when a process blocks and restored when it resumes.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-08T19:32:44.543759-05:00","updated_at":"2025-12-08T19:51:36.474232-05:00","closed_at":"2025-12-08T19:51:36.474232-05:00","dependencies":[{"issue_id":"gneiss-lang-q2d","depends_on_id":"gneiss-lang-94p","type":"parent-child","created_at":"2025-12-08T19:32:44.544459-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-qkt","title":"Implement answer-type polymorphism for delimited continuations","description":"Extend the type system from simplified shift/reset typing (k : a -\u003e a) to full Danvy-Filinski/Asai-Kameyama answer-type polymorphism with k : ∀t.(τ/t → α/t).\n\nKey changes:\n1. Add InferResult struct to track answer types (before/after)\n2. Add Type::Continuation variant for continuation types\n3. Change infer_expr to return InferResult\n4. Implement proper answer-type threading in application\n5. Implement Reset/Shift typing rules per the formal spec\n\nReference: docs/delim_cont_types.md","notes":"COMPLETE - Full answer-type polymorphism implemented:\n\nPhase 1 Complete:\n- Changed Type::Arrow from tuple to struct with 4 fields: { arg, ret, ans_in, ans_out }\n- All type utility functions updated\n\nPhase 2 Complete - Full answer-type threading:\n- BinOp: left.ans_out = right.ans_in (left-to-right threading)\n- Lambda: captures body's answer types in function type\n- Application: full APP rule from Danvy-Filinski with backward continuation flow\n- Let: value.ans_out = body.ans_in (sequential threading)\n- Reset: constrains body.answer_before = body.ty, returns body.answer_after\n- Shift: creates pure function type for k\n\nPhase 3 Complete - Property tests:\n- Created tests/proptest_answer_types.rs with 32 comprehensive tests\n- Purity tests (literals, lambdas, reset)\n- Threading tests (BinOp, Let, If, App)\n- Reset/Shift rule tests \n- Polymorphism tests\n- Regression tests for specific bugs\n- Stress tests\n\nKey test case working:\n- `reset (1 + shift (fun k -\u003e \"hello\"))` now correctly types as String\n- All 32 property tests pass\n- All 165+ existing tests pass","status":"closed","priority":1,"issue_type":"feature","assignee":"claude","created_at":"2025-12-11T22:58:59.988631-05:00","updated_at":"2025-12-12T01:49:47.977188-05:00","closed_at":"2025-12-12T01:49:47.977188-05:00","labels":["answer-types","continuations","type-system"]}
{"id":"gneiss-lang-rns","title":"Implement full answer-type polymorphism for continuation k","description":"Currently, abstracting shift into a function (e.g., `let yield x = shift (fun k -\u003e x :: k ())`) doesn't work because the continuation k's return type gets constrained at definition time.\n\nFor `yield` to work, k needs true answer-type polymorphism: `k : ∀α. τ → α` where α is instantiated fresh at each call site within the shift body.\n\nWithout this, users must use inline shift expressions instead of abstracting them into reusable functions.","notes":"Session 2025-12-12: Implemented full answer-type polymorphism for continuation k.\n\nChanges:\n1. src/infer.rs (Shift case, lines 884-909): Changed k from monomorphic binding to polymorphic scheme ∀t.(τ/t → α/t) using Type::new_generic(0)\n\n2. src/infer.rs (print builtin, lines 1220-1231): Fixed print to be properly polymorphic in both arg type and answer type using explicit Scheme with Generic types\n\n3. examples/cont/gen.gn (line 15): Added parens around if expression to fix parser precedence issue\n\nThe key insight: The continuation k in shift was being bound as a monomorphic type via bind_pattern (which wraps in Scheme::mono). By creating an explicit Scheme with num_generics=1 and using Type::new_generic(0) for the answer types, each use of k now gets fresh answer type variables via instantiation.\n\nAlso discovered/fixed:\n- Parser precedence issue: `if ... then ... else ...; expr` parses as `if ... then ... else (...; expr)`, not `(if ... then ... else ...); expr`. Need parens around if when followed by semicolon.\n- print builtin wasn't polymorphic due to Type::arrow using level-0 vars that don't get generalized. Fixed by using explicit Generic types.\n\ngen.gn now works:\n```\n=== Running ===\nExample 1: Simple yields\n[1, 2, 3]\nExample 2: Conditional yields\n[5, 10, 15]\n```\n\nAll 197 tests pass.","status":"closed","priority":2,"issue_type":"feature","assignee":"claude","created_at":"2025-12-12T17:50:02.333205-05:00","updated_at":"2025-12-12T18:32:46.212531-05:00","closed_at":"2025-12-12T18:32:46.212531-05:00","labels":["answer-types","continuations","polymorphism","type-system"]}
{"id":"gneiss-lang-rr9","title":"Implement user-defined infix operators","description":"Add support for user-defined infix operators with explicit precedence/associativity declarations (Haskell-style).\n\nSyntax:\n```gneiss\ninfixl 4 \u003c|\u003e\ninfixr 5 \u003e\u003e\nlet (\u003c|\u003e) p1 p2 = ...\nlet p1 \u003c|\u003e p2 = ...\n```\n\nRequires changes to lexer, parser, AST, type inference, and evaluator.","notes":"COMPLETED: User-defined infix operators fully implemented.\n\nChanges:\n- Phase 1: operators.rs - OperatorTable, OpInfo with precedence/associativity\n- Phase 2: Lexer - OpSymbol token for generic operator sequences\n- Phase 3: AST - BinOp::UserDefined, FixityDecl, Decl::Fixity, Decl::OperatorDef\n- Phase 4: Parser - Pratt parser (parse_expr_binary) replacing hardcoded precedence chain, operator definition parsing (`let (\u003c|\u003e) a b = ...` and `let a \u003c|\u003e b = ...`)\n- Phase 5: Type inference - looks up user operators as functions with a -\u003e b -\u003e c signature\n- Phase 6: Evaluation - curried application via Frame::ApplyTo continuation\n\nTests added:\n- test_user_defined_operator_basic\n- test_user_defined_operator_prefix_syntax  \n- test_user_defined_operator_complex\n\nAll 153 tests passing.","status":"in_progress","priority":1,"issue_type":"feature","assignee":"claude","created_at":"2025-12-13T20:21:33.121795-05:00","updated_at":"2025-12-13T20:46:28.18475-05:00","labels":["language-feature","operators","parser"]}
{"id":"gneiss-lang-s9m","title":"Add line:column position tracking","description":"Convert byte offset (Span.start, Span.end) to line:column positions.\n\nCurrently Span stores byte offsets but errors don't show line numbers. Need infrastructure to:\n- Track line boundaries in source text\n- Convert byte offset to (line, column) pair\n- Handle multi-byte UTF-8 characters correctly\n\nThis is foundational for all other error reporting improvements.","status":"closed","priority":1,"issue_type":"task","assignee":"claude","created_at":"2025-12-11T19:18:12.234246-05:00","updated_at":"2025-12-13T12:03:02.575427-05:00","closed_at":"2025-12-13T12:03:02.575427-05:00","labels":["error-handling","phase-2"],"dependencies":[{"issue_id":"gneiss-lang-s9m","depends_on_id":"gneiss-lang-803","type":"blocks","created_at":"2025-12-11T19:18:12.235337-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-t7b","title":"Optimize type inference with union-find","description":"Current type variable unification uses naive linked representation without union-find optimizations.\n\nCurrent approach (types.rs, infer.rs):\n- TypeVar::Link just points to another type\n- resolve() follows chain every time - O(n) per lookup\n- No path compression\n- No union by rank\n\nShould implement:\n1. Path compression in resolve() - update intermediate links to point to root\n2. Union by rank - track tree depth, attach shorter under taller\n\nLow priority - works fine for small programs, but would improve performance for larger codebases.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-08T19:54:39.33895-05:00","updated_at":"2025-12-08T19:54:39.33895-05:00","labels":["optimization","type-system"]}
{"id":"gneiss-lang-tuj","title":"Phase 1: Add typeclass tokens to lexer and AST","description":"Add the foundational tokens and AST structures for typeclasses.\n\n**Lexer (src/lexer.rs):**\n- Add tokens: `Trait`, `Impl`, `For`, `Where`, `Val`, `End`\n- Update keyword matching in `scan_identifier()`\n\n**AST (src/ast.rs):**\nAdd two new Decl variants:\n```rust\nTrait {\n    name: Ident,\n    type_param: Ident,\n    supertraits: Vec\u003cIdent\u003e,\n    methods: Vec\u003c(Ident, TypeExpr)\u003e,\n}\nInstance {\n    trait_name: Ident,\n    target_type: TypeExpr,\n    constraints: Vec\u003c(Ident, Ident)\u003e,\n    methods: Vec\u003c(Ident, Expr)\u003e,\n}\n```\n\n**Tests:**\n- `test_typeclass_tokens` - verify all 6 new tokens are recognized\n- `test_trait_not_ident` - ensure \"trait\" is keyword, not identifier","status":"closed","priority":1,"issue_type":"task","assignee":"claude","created_at":"2025-12-10T16:31:36.770056-05:00","updated_at":"2025-12-10T16:33:35.34184-05:00","closed_at":"2025-12-10T16:33:35.34184-05:00","labels":["ast","lexer","phase-1"],"dependencies":[{"issue_id":"gneiss-lang-tuj","depends_on_id":"gneiss-lang-k1m","type":"parent-child","created_at":"2025-12-10T16:31:44.929718-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-un1","title":"Unify List type representation to Type::Constructor","description":"Type system has two incompatible representations for list types:\n1. `Type::List(Rc\u003cType\u003e)` - used by [1,2,3] literals, :: operator, list patterns\n2. `Type::Constructor { name: \"List\" }` - used by type annotations `List Int`\n\nThese don't unify, causing type errors when annotating list expressions.\n\nSolution: Remove Type::List entirely, use Type::Constructor everywhere, add [Int] type syntax.","notes":"Implemented:\n1. Removed Type::List variant - now use Type::Constructor { name: \"List\" }\n2. Added Type::list(elem) helper function\n3. Added TypeExprKind::List for [a] type annotation syntax  \n4. Added val declaration for standalone type signatures\n5. Display impl special-cases List to show as [Int] not List Int\n6. All 224 tests pass","status":"closed","priority":1,"issue_type":"bug","assignee":"claude","created_at":"2025-12-13T18:51:32.741812-05:00","updated_at":"2025-12-13T19:00:11.967014-05:00","closed_at":"2025-12-13T19:00:11.967014-05:00"}
{"id":"gneiss-lang-vhf","title":"Update EvalError to use error framework","description":"Update EvalError to carry span information and use the new error reporting framework.\n\nRuntime errors need to show:\n- Location in source where error occurred\n- For pattern match failures, show the match expression\n- For division by zero, show the division operation\n\nMay also want stack traces for complex programs.","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-11T19:18:39.391376-05:00","updated_at":"2025-12-11T19:18:39.391376-05:00","labels":["error-handling","phase-2","runtime"],"dependencies":[{"issue_id":"gneiss-lang-vhf","depends_on_id":"gneiss-lang-720","type":"blocks","created_at":"2025-12-11T19:18:39.392428-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-vnk","title":"TypeMismatch errors sometimes lack source location","description":"During error infrastructure work, noticed that `TypeError::TypeMismatch` often has `span: None`, which means no source snippet is shown.\n\nExample: `let x = 1 + \"hello\"` produces a type mismatch error without source context.\n\nThe span is lost during unification when the error is generated deep in the type checker, not at the expression level.\n\nTo fix: Thread span information through unification, or capture span at the call site before unifying.","notes":"Session 2025-12-13:\nFIXED: Added unify_at() method and updated key call sites:\n- Function application (func.span, arg.span)\n- If-else (cond.span, else_branch.span) \n- Binary ops (left.span, right.span)\n- Unary ops (operand.span)\n- Match arms (arm.body.span)\n\nTests: All pass, snapshot updated to include source location.\n\nNOT COVERED: Some deeper unification errors still lack spans (e.g., answer type threading). These are less user-facing.","status":"closed","priority":3,"issue_type":"bug","assignee":"claude","created_at":"2025-12-13T12:51:14.229287-05:00","updated_at":"2025-12-13T18:31:47.965582-05:00","closed_at":"2025-12-13T18:18:11.068338-05:00","labels":["error-handling","type-system","ux"]}
{"id":"gneiss-lang-w3i","title":"Implement module name resolution","description":"Map module names to file paths.\n\nDesign decisions needed:\n- Module `Foo.Bar` maps to `Foo/Bar.gn` or `foo/bar.gn`?\n- Search paths (current dir, lib dir, etc.)\n- Case sensitivity\n\nImplementation:\n- Module resolver that takes module name, returns file path\n- Cache of loaded modules\n- Error for missing modules","status":"open","priority":2,"issue_type":"task","created_at":"2025-12-11T19:19:09.169029-05:00","updated_at":"2025-12-11T19:19:09.169029-05:00","labels":["modules","phase-3"],"dependencies":[{"issue_id":"gneiss-lang-w3i","depends_on_id":"gneiss-lang-7yx","type":"blocks","created_at":"2025-12-11T19:19:09.169988-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-wzl","title":"Infinite type error with let rec + continuation-based operators","description":"When using `let rec` with operators that internally use `shift` (like parser combinator `\u003c|\u003e`), the type system reports an infinite type error.\n\n**Failing example:**\n```gneiss\nlet rec many p =\n    (fun () -\u003e\n        let x = p () in\n        let xs = many p () in\n        x :: xs\n    ) \u003c|\u003e (fun () -\u003e [])\n```\n\nError: `I detected an infinite type: type variable 137 occurs in [Char] -\u003e ParseResult ()/t132 -\u003e [t117]/t137`\n\n**Root cause:**\nThe `\u003c|\u003e` operator uses `shift` internally, and the recursive reference to `many` creates a type constraint where a type variable appears in its own definition through the continuation's answer type threading.\n\n**This is NOT the same as gneiss-lang-1dd** (returning continuations). This is about recursion interacting with answer-type polymorphism.\n\n**Potential solutions:**\n1. Implement effect polymorphism (row-polymorphic effects)\n2. Use a different type system approach for recursive continuation-using functions\n3. Accept as limitation and document workarounds\n\n**Workaround:**\nNone known that preserves the continuation-based backtracking semantics.","status":"open","priority":2,"issue_type":"bug","created_at":"2025-12-13T21:40:45.689067-05:00","updated_at":"2025-12-13T21:40:45.689067-05:00","labels":["continuations","limitation","recursion","type-system"]}
{"id":"gneiss-lang-x79","title":"Add history and line editing support to REPL","description":"Add proper line editing to the REPL:\n- Up/down arrows for history navigation\n- Left/right arrows for cursor movement\n- Backspace/delete work properly\n- History persisted across sessions (optional)\n\nResearch options for Rust line editing libraries.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-11T19:19:38.652098-05:00","updated_at":"2025-12-11T19:19:38.652098-05:00","labels":["phase-4","repl"],"dependencies":[{"issue_id":"gneiss-lang-x79","depends_on_id":"gneiss-lang-zex","type":"blocks","created_at":"2025-12-11T19:19:38.653519-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-y4g","title":"Phase 3: Type system extensions for typeclasses","description":"Add the core type system structures needed for typeclasses.\n\n**New structures in `src/types.rs`:**\n```rust\n/// A predicate: TraitName applied to a type (e.g., Show Int, Eq (List a))\npub struct Pred {\n    pub trait_name: String,\n    pub ty: Type,\n}\n\n/// Trait definition\npub struct TraitInfo {\n    pub name: String,\n    pub type_param: String,\n    pub supertraits: Vec\u003cString\u003e,\n    pub methods: HashMap\u003cString, Type\u003e,\n}\n\n/// Instance definition  \npub struct InstanceInfo {\n    pub trait_name: String,\n    pub head: Type,\n    pub constraints: Vec\u003cPred\u003e,\n    pub methods: HashMap\u003cString, Expr\u003e,\n}\n\n/// Class environment\npub struct ClassEnv {\n    pub traits: HashMap\u003cString, TraitInfo\u003e,\n    pub instances: Vec\u003cInstanceInfo\u003e,\n}\n```\n\n**Tests:**\n- `test_pred_equality`\n- `test_pred_apply_substitution` \n- `test_class_env_register_trait`\n- `test_class_env_register_instance`","status":"closed","priority":1,"issue_type":"task","assignee":"claude","created_at":"2025-12-10T16:36:11.325719-05:00","updated_at":"2025-12-10T18:58:29.560781-05:00","closed_at":"2025-12-10T18:58:29.560781-05:00","labels":["phase-3","types"],"dependencies":[{"issue_id":"gneiss-lang-y4g","depends_on_id":"gneiss-lang-k1m","type":"parent-child","created_at":"2025-12-10T18:48:04.187097-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-yga","title":"Implement basic select","description":"Implement select for waiting on multiple channels.\n\nCurrently returns error: \"select not yet implemented\" (eval.rs line 365-367).\n\nRequirements:\n- Wait on multiple receive operations\n- Non-deterministic choice when multiple channels ready\n- Return the value from whichever channel fires first\n\nSyntax already parsed: select [ ch1 -\u003e handler1 | ch2 -\u003e handler2 ]\n\nCritical file: src/eval.rs","notes":"## Implementation Complete\n\n### Changes Made\n\n**Lexer (`src/lexer.rs`):**\n- Added tokens: `Select`, `End`, `LArrow` (`\u003c-`)\n- Added keyword recognition for `select` and `end`\n- Added `\u003c-` operator lexing\n\n**Parser (`src/parser.rs`):**\n- Added `parse_select()` method for the new syntax:\n  ```\n  select\n  | pattern \u003c- channel_expr -\u003e body_expr\n  | pattern \u003c- channel_expr -\u003e body_expr\n  end\n  ```\n- Integrated into expression parsing\n\n**Type Inference (`src/infer.rs`):**\n- Proper type checking for select:\n  - Channels must be `Channel\u003cT\u003e` types\n  - Patterns bind to channel element type\n  - All arm bodies must return compatible types\n- Added type inference tests\n\n**Runtime (`src/runtime.rs`):**\n- Added `ProcessState::BlockedSelect(Vec\u003cChannelId\u003e)` for processes blocked on select\n- Added `ProcessContinuation::ResumeAfterSelect` for proper resumption\n- Added `select_fired_channel` field to `Process` to track which channel fired\n- Added `try_recv()` for non-blocking receive (used by select)\n- Added `block_on_select()` to register on multiple channels\n- Updated `send()` to handle waking select-blocked receivers\n- Updated `is_deadlocked()` to only detect true deadlocks (main blocked, not just spawned processes)\n- Added `main_pid` tracking\n\n**Eval (`src/eval.rs`):**\n- Added `Frame::SelectChans` for evaluating channel expressions\n- Added `Frame::SelectReady` for performing the select\n- Added `BlockReason::Select` for blocked state\n- Proper handling of select resumption after being woken\n\n### Tests Added\n- `test_select_basic` - basic select with one active channel\n- `test_select_second_channel` - select where second arm fires\n- `test_select_with_pattern` - select with tuple pattern matching\n- `test_select_deadlock_no_senders` - deadlock detection works\n- `test_select_multiple_ready` - non-deterministic choice when multiple ready\n- `test_select_server_pattern` - request/response pattern\n- `test_select_type_inference_consistent` - type inference succeeds\n- `test_select_type_inference_mismatch` - type inference rejects mismatched types\n\nAll 55 tests pass.","status":"closed","priority":2,"issue_type":"task","assignee":"claude","created_at":"2025-12-08T19:33:08.377697-05:00","updated_at":"2025-12-09T12:26:01.844039-05:00","closed_at":"2025-12-09T12:26:01.844039-05:00","dependencies":[{"issue_id":"gneiss-lang-yga","depends_on_id":"gneiss-lang-94p","type":"parent-child","created_at":"2025-12-08T19:33:08.378447-05:00","created_by":"daemon"},{"issue_id":"gneiss-lang-yga","depends_on_id":"gneiss-lang-z43","type":"blocks","created_at":"2025-12-08T19:33:08.379189-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-z43","title":"Wire up scheduler to resume processes","description":"Fix run_scheduler to actually resume blocked processes with their continuation.\n\nCurrently run_scheduler (eval.rs lines 635-678) immediately marks processes Done after AfterRecv/AfterSend instead of resuming execution. Need to:\n\n- Store the captured continuation when process blocks\n- When unblocked, resume by invoking continuation with received value\n- Properly interleave multiple processes\n\nCritical file: src/eval.rs (run_scheduler function)","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-08T19:32:57.271102-05:00","updated_at":"2025-12-08T22:43:41.619171-05:00","closed_at":"2025-12-08T22:43:41.619171-05:00","dependencies":[{"issue_id":"gneiss-lang-z43","depends_on_id":"gneiss-lang-94p","type":"parent-child","created_at":"2025-12-08T19:32:57.27175-05:00","created_by":"daemon"},{"issue_id":"gneiss-lang-z43","depends_on_id":"gneiss-lang-3xz","type":"blocks","created_at":"2025-12-08T19:32:57.27233-05:00","created_by":"daemon"}]}
{"id":"gneiss-lang-zex","title":"Improve REPL usability","description":"Improve the REPL with better editing, history, and commands.\n\nCurrent state:\n- Basic readline with no history\n- No multi-line input\n- Limited commands (:quit, :help, :type)\n\nGoals:\n- History with up/down arrow navigation\n- Line editing (cursor movement, delete, etc.)\n- Multi-line input for complex expressions\n- :load command to load files\n- :env command to show bindings","status":"open","priority":3,"issue_type":"epic","created_at":"2025-12-11T19:19:33.089269-05:00","updated_at":"2025-12-11T19:19:33.089269-05:00","labels":["phase-4","repl","ux"]}
{"id":"gneiss-lang-zh5","title":"Add mutable references (ref and !)","description":"Add mutable reference support for effect handler patterns:\n\n- `ref x` - create a reference to value x\n- `!r` - dereference reference r\n- `r := v` - mutate reference r to value v\n\nThis enables implementing state effects without threading state through continuations.\n\nEstimated scope:\n- Lexer: Add Ref, Bang, ColonEquals tokens\n- Parser: Parse ref expressions, dereference prefix, assignment\n- Types: Add Ref type constructor with mutability tracking\n- Inference: Handle ref creation, dereference, and mutation\n- Evaluator: Runtime support for mutable references\n\nExample usage:\n```\nlet counter = ref 0 in\n!counter := !counter + 1;\n!counter  -- returns 1\n```","status":"open","priority":3,"issue_type":"feature","created_at":"2025-12-13T13:33:03.951799-05:00","updated_at":"2025-12-13T13:33:03.951799-05:00","labels":["effects","language-feature"]}
