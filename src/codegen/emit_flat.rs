//! C Code Generation from Flat IR
//!
//! Emits C source code from FlatProgram (post-closure conversion).
//! All lambdas have been lifted to top-level functions with explicit MakeClosure.

use std::collections::{HashMap, HashSet};
use std::fmt::Write;

use super::closure::{FlatProgram, FlatFn, FlatExpr, FlatAtom, FlatAlt, EnvStructId, EnvStruct};
use super::core_ir::{CoreLit, PrimOp, VarId};

// ============================================================================
// Code Emitter
// ============================================================================

pub struct FlatEmitter {
    /// Output buffer
    output: String,
    /// Current indentation level
    indent: usize,
    /// Map from VarId to C variable name
    var_names: HashMap<VarId, String>,
    /// Map of top-level function VarIds to their C names
    top_level_funcs: HashMap<VarId, String>,
    /// Map of function arities
    func_arities: HashMap<VarId, usize>,
    /// Map of function name to arity
    func_name_arities: HashMap<String, usize>,
    /// Functions that have an env parameter (captures)
    funcs_with_env: HashSet<String>,
    /// Counter for generating unique names
    name_counter: u32,
    /// Top-level function definitions
    function_defs: String,
    /// Environment structs for closure captures (EnvStructId -> EnvStruct)
    env_structs: HashMap<EnvStructId, EnvStruct>,
}

impl FlatEmitter {
    pub fn new() -> Self {
        FlatEmitter {
            output: String::new(),
            indent: 0,
            var_names: HashMap::new(),
            top_level_funcs: HashMap::new(),
            func_arities: HashMap::new(),
            func_name_arities: HashMap::new(),
            funcs_with_env: HashSet::new(),
            name_counter: 0,
            function_defs: String::new(),
            env_structs: HashMap::new(),
        }
    }

    /// Emit a complete C program from FlatProgram
    pub fn emit_program(&mut self, program: &FlatProgram) -> String {
        // Build env struct lookup for captured variable extraction
        for env_struct in &program.env_structs {
            self.env_structs.insert(env_struct.id, env_struct.clone());
        }

        // Header
        self.output.push_str("// Generated by gneic - Gneiss Compiler\n");
        self.output.push_str("// DO NOT EDIT\n\n");
        self.output.push_str("#include \"gn_runtime.h\"\n\n");

        // Register all functions
        for fun in &program.functions {
            let c_name = format!("fn_{}", mangle_name(&fun.name));
            self.top_level_funcs.insert(fun.var_id, c_name.clone());
            self.func_arities.insert(fun.var_id, fun.params.len());
            self.func_name_arities.insert(c_name.clone(), fun.params.len());
            if fun.env_param.is_some() {
                self.funcs_with_env.insert(c_name);
            }
        }

        // Register builtins with their arities
        for (var_id, name) in &program.builtins {
            let c_name = format!("gn_{}", name);
            self.top_level_funcs.insert(*var_id, c_name.clone());

            // Infer builtin arity from the name
            let arity = get_builtin_arity(name);
            if arity > 0 {
                self.func_arities.insert(*var_id, arity);
                self.func_name_arities.insert(c_name, arity);
            }
        }

        // Emit forward declarations
        self.output.push_str("// Forward declarations\n");
        for fun in &program.functions {
            self.emit_forward_decl(fun);
        }
        self.output.push('\n');

        // Emit function definitions
        self.output.push_str("// Function definitions\n");
        for fun in &program.functions {
            self.emit_function(fun);
        }

        // Emit main
        self.emit_main(&program.main);

        self.output.clone()
    }

    fn emit_forward_decl(&mut self, fun: &FlatFn) {
        // All functions have env as first parameter for uniform closure calling convention
        let params: Vec<String> = std::iter::once("gn_value* env".to_string())
            .chain(
                fun.params
                    .iter()
                    .enumerate()
                    .map(|(i, _)| format!("gn_value arg{}", i)),
            )
            .collect();

        let c_name = format!("fn_{}", mangle_name(&fun.name));
        writeln!(
            self.output,
            "static gn_value {}({});",
            c_name,
            params.join(", ")
        )
        .unwrap();
    }

    fn emit_function(&mut self, fun: &FlatFn) {
        // Clear var names for this function
        self.var_names.clear();
        for (var_id, name) in &self.top_level_funcs {
            self.var_names.insert(*var_id, name.clone());
        }

        // Bind parameters
        for (i, param) in fun.params.iter().enumerate() {
            let name = format!("arg{}", i);
            self.var_names.insert(*param, name);
        }

        // Build parameter list
        let params: Vec<String> = std::iter::once("gn_value* env".to_string())
            .chain(
                fun.params
                    .iter()
                    .enumerate()
                    .map(|(i, _)| format!("gn_value arg{}", i)),
            )
            .collect();

        let c_name = format!("fn_{}", mangle_name(&fun.name));

        writeln!(
            self.output,
            "static gn_value {}({}) {{",
            c_name,
            params.join(", ")
        )
        .unwrap();

        // Extract captured variables from env, or mark env as unused
        if let Some(env_id) = &fun.env_param {
            if let Some(env_struct) = self.env_structs.get(env_id) {
                // Extract each captured variable from the env array
                for (index, (var_id, hint, _ty)) in env_struct.fields.iter().enumerate() {
                    let cap_name = format!("cap_{}", var_id.0);
                    writeln!(
                        self.output,
                        "    gn_value {} = env[{}]; /* {} */",
                        cap_name, index, hint
                    ).unwrap();
                    // Bind this captured variable so the body can reference it
                    self.var_names.insert(*var_id, cap_name);
                }
            }
        } else {
            // No captures - suppress unused parameter warning
            self.output.push_str("    (void)env;\n");
        }

        self.indent = 1;

        // Emit function body
        let mut stmts = String::new();
        std::mem::swap(&mut stmts, &mut self.function_defs);
        let body = self.emit_expr(&fun.body);
        std::mem::swap(&mut stmts, &mut self.function_defs);

        self.output.push_str(&stmts);
        writeln!(self.output, "{}return {};", self.pad(), body).unwrap();
        self.output.push_str("}\n\n");
    }

    fn emit_main(&mut self, main_expr: &Option<FlatExpr>) {
        let has_fn_main = self.top_level_funcs.values().any(|n| n == "fn_main");

        if let Some(expr) = main_expr {
            self.indent = 1;
            self.var_names.clear();
            for (var_id, name) in &self.top_level_funcs {
                self.var_names.insert(*var_id, name.clone());
            }

            let mut stmts = String::new();
            std::mem::swap(&mut stmts, &mut self.function_defs);
            let result = self.emit_expr(expr);
            std::mem::swap(&mut stmts, &mut self.function_defs);

            self.output.push_str("// Main entry point\n");
            self.output.push_str("int main(int argc, char** argv) {\n");
            self.output.push_str("    gn_init(argc, argv);\n");
            self.output.push_str(&stmts);
            writeln!(self.output, "    gn_value result = {};", result).unwrap();
            self.output.push_str("    gn_print(result);\n");
            self.output.push_str("    gn_println();\n");
            self.output.push_str("    gn_shutdown();\n");
            self.output.push_str("    return 0;\n");
            self.output.push_str("}\n");
        } else if has_fn_main {
            self.output.push_str("// Main entry point\n");
            self.output.push_str("int main(int argc, char** argv) {\n");
            self.output.push_str("    gn_init(argc, argv);\n");
            self.output.push_str("    gn_value result = fn_main(NULL, GN_UNIT);\n");
            self.output.push_str("    gn_print(result);\n");
            self.output.push_str("    gn_println();\n");
            self.output.push_str("    gn_shutdown();\n");
            self.output.push_str("    return 0;\n");
            self.output.push_str("}\n");
        } else {
            self.output.push_str("// Main entry point\n");
            self.output.push_str("int main(int argc, char** argv) {\n");
            self.output.push_str("    gn_init(argc, argv);\n");
            self.output.push_str("    gn_shutdown();\n");
            self.output.push_str("    return 0;\n");
            self.output.push_str("}\n");
        }
    }

    fn emit_expr(&mut self, expr: &FlatExpr) -> String {
        match expr {
            FlatExpr::Var(var) => {
                let name = self.get_var_name(*var);

                // Check if this is a function being used as a value
                if let Some(arity) = self.func_arities.get(var).copied()
                    .or_else(|| self.func_name_arities.get(&name).copied())
                {
                    if arity == 0 {
                        // CAF - call it
                        return format!("{}(NULL)", name);
                    } else {
                        // Function used as value - wrap in closure
                        return match arity {
                            1 => format!("gn_make_closure1((void*){})", name),
                            2 => format!("gn_make_closure2((void*){})", name),
                            _ => format!("gn_make_closure((void*){}, {}, 0, NULL)", name, arity),
                        };
                    }
                }
                name
            }

            FlatExpr::Lit(lit) => emit_literal(lit),

            FlatExpr::Let { name, name_hint, value, body } => {
                let var_name = self.fresh_var(name_hint.as_deref());
                self.var_names.insert(*name, var_name.clone());
                let value_expr = self.emit_atom(value);
                writeln!(self.function_defs, "{}gn_value {} = {};", self.pad(), var_name, value_expr).unwrap();
                self.emit_expr(body)
            }

            FlatExpr::LetExpr { name, name_hint, value, body } => {
                let var_name = self.fresh_var(name_hint.as_deref());
                self.var_names.insert(*name, var_name.clone());
                let value_expr = self.emit_expr(value);
                writeln!(self.function_defs, "{}gn_value {} = {};", self.pad(), var_name, value_expr).unwrap();
                self.emit_expr(body)
            }

            FlatExpr::MakeClosure { func, arity, captures, .. } => {
                let c_name = format!("fn_{}", mangle_name(func));

                if captures.is_empty() {
                    match arity {
                        1 => format!("gn_make_closure1((void*){})", c_name),
                        2 => format!("gn_make_closure2((void*){})", c_name),
                        _ => format!("gn_make_closure((void*){}, {}, 0, NULL)", c_name, arity),
                    }
                } else {
                    // Closure with captures
                    let capture_names: Vec<String> = captures
                        .iter()
                        .map(|v| self.get_var_name(*v))
                        .collect();
                    let captures_array = format!("(gn_value[]){{{}}}", capture_names.join(", "));
                    format!(
                        "gn_make_closure((void*){}, {}, {}, {})",
                        c_name, arity, captures.len(), captures_array
                    )
                }
            }

            FlatExpr::CallDirect { func, args, .. } => {
                let c_name = format!("fn_{}", mangle_name(func));
                let args_str: Vec<String> = args.iter().map(|a| self.get_var_name(*a)).collect();

                // Pass NULL for env and then args
                let all_args = std::iter::once("NULL".to_string())
                    .chain(args_str)
                    .collect::<Vec<_>>();
                format!("{}({})", c_name, all_args.join(", "))
            }

            FlatExpr::CallClosure { closure, args } => {
                let closure_name = self.get_var_name(*closure);
                let args_str: Vec<String> = args.iter().map(|a| self.get_var_name(*a)).collect();

                // Check if this is a runtime builtin (gn_*) that should be called directly
                if closure_name.starts_with("gn_") {
                    // Runtime builtin - direct call, no env parameter
                    format!("{}({})", closure_name, args_str.join(", "))
                } else if closure_name.starts_with("fn_") && !args_str.is_empty() {
                    // Top-level function called with extra args (over-application)
                    // Call the function with first arg to get a closure, then apply rest
                    let first_arg = &args_str[0];
                    let mut result = format!("{}(NULL, {})", closure_name, first_arg);
                    for arg in &args_str[1..] {
                        result = format!("gn_apply({}, {})", result, arg);
                    }
                    result
                } else {
                    // Closure - chain gn_apply for each argument
                    let mut result = closure_name;
                    for arg in &args_str {
                        result = format!("gn_apply({}, {})", result, arg);
                    }
                    result
                }
            }

            FlatExpr::TailCallDirect { func, args, .. } => {
                // Same as CallDirect for now (TCO later)
                let c_name = format!("fn_{}", mangle_name(func));
                let args_str: Vec<String> = args.iter().map(|a| self.get_var_name(*a)).collect();
                let all_args = std::iter::once("NULL".to_string())
                    .chain(args_str)
                    .collect::<Vec<_>>();
                format!("{}({})", c_name, all_args.join(", "))
            }

            FlatExpr::TailCallClosure { closure, args } => {
                let closure_name = self.get_var_name(*closure);
                let args_str: Vec<String> = args.iter().map(|a| self.get_var_name(*a)).collect();

                // Check if this is a runtime builtin (gn_*) that should be called directly
                if closure_name.starts_with("gn_") {
                    // Runtime builtin - direct call
                    format!("{}({})", closure_name, args_str.join(", "))
                } else if closure_name.starts_with("fn_") && !args_str.is_empty() {
                    // Top-level function called with extra args (over-application)
                    let first_arg = &args_str[0];
                    let mut result = format!("{}(NULL, {})", closure_name, first_arg);
                    for arg in &args_str[1..] {
                        result = format!("gn_apply({}, {})", result, arg);
                    }
                    result
                } else {
                    // Closure - chain gn_apply
                    let mut result = closure_name;
                    for arg in &args_str {
                        result = format!("gn_apply({}, {})", result, arg);
                    }
                    result
                }
            }

            FlatExpr::Alloc { tag, ctor_name, fields, .. } => {
                let fields_str: Vec<String> = fields.iter().map(|f| self.get_var_name(*f)).collect();
                let name = ctor_name.as_deref().unwrap_or("anon");

                if fields.is_empty() {
                    format!("GN_CTOR({}, 0) /* {} */", tag, name)
                } else {
                    format!(
                        "gn_alloc({}, {}, (gn_value[]){{{}}})",
                        tag, fields.len(), fields_str.join(", ")
                    )
                }
            }

            FlatExpr::Case { scrutinee, alts, default } => {
                self.emit_case(*scrutinee, alts, default.as_deref())
            }

            FlatExpr::If { cond, then_branch, else_branch } => {
                let result_var = self.fresh_var(Some("if_result"));
                let cond_name = self.get_var_name(*cond);

                writeln!(self.function_defs, "{}gn_value {};", self.pad(), result_var).unwrap();
                writeln!(self.function_defs, "{}if (GN_IS_TRUE({})) {{", self.pad(), cond_name).unwrap();

                self.indent += 1;
                let then_expr = self.emit_expr(then_branch);
                writeln!(self.function_defs, "{}{} = {};", self.pad(), result_var, then_expr).unwrap();
                self.indent -= 1;

                writeln!(self.function_defs, "{}}} else {{", self.pad()).unwrap();

                self.indent += 1;
                let else_expr = self.emit_expr(else_branch);
                writeln!(self.function_defs, "{}{} = {};", self.pad(), result_var, else_expr).unwrap();
                self.indent -= 1;

                writeln!(self.function_defs, "{}}}", self.pad()).unwrap();

                result_var
            }

            FlatExpr::LetRec { name, lifted_func, body, .. } => {
                // The function is already lifted - just bind the name
                let c_name = format!("fn_{}", mangle_name(lifted_func));
                self.var_names.insert(*name, c_name);
                self.emit_expr(body)
            }

            FlatExpr::LetRecMutual { bindings, body } => {
                // All functions are already lifted - just bind names
                for (var_id, func_name) in bindings {
                    let c_name = format!("fn_{}", mangle_name(func_name));
                    self.var_names.insert(*var_id, c_name);
                }
                self.emit_expr(body)
            }

            FlatExpr::Seq { first, second } => {
                let first_expr = self.emit_expr(first);
                writeln!(self.function_defs, "{}{};", self.pad(), first_expr).unwrap();
                self.emit_expr(second)
            }

            FlatExpr::PrimOp { op, args } => emit_primop(op, args, &self.var_names),

            FlatExpr::Return(var) => self.get_var_name(*var),

            FlatExpr::ExternCall { name, args } => {
                let args_str: Vec<String> = args.iter().map(|a| self.get_var_name(*a)).collect();
                format!("{}({})", name, args_str.join(", "))
            }

            FlatExpr::DictCall { dict, method, args } => {
                let dict_name = self.get_var_name(*dict);
                let args_str: Vec<String> = args.iter().map(|a| self.get_var_name(*a)).collect();

                if args.is_empty() {
                    format!("gn_dict_get({}, \"{}\")", dict_name, method)
                } else {
                    let mut result = format!("gn_dict_get({}, \"{}\")", dict_name, method);
                    for arg in &args_str {
                        result = format!("gn_apply({}, {})", result, arg);
                    }
                    result
                }
            }

            FlatExpr::DictValue { trait_name, instance_ty } => {
                format!("(&{}_{}_dict)", trait_name, instance_ty)
            }

            FlatExpr::DictRef(var) => self.get_var_name(*var),

            FlatExpr::Proj { tuple, index } => {
                let tuple_name = self.get_var_name(*tuple);
                format!("GN_FIELD({}, {})", tuple_name, index)
            }

            FlatExpr::Error(msg) => {
                format!("gn_panic(\"{}\")", escape_string(msg))
            }

            FlatExpr::Perform { effect_name, op_name, .. } => {
                let effect = effect_name.as_deref().unwrap_or("?");
                let op = op_name.as_deref().unwrap_or("?");
                format!("gn_panic(\"perform {}.{} not implemented\")", effect, op)
            }

            FlatExpr::Handle { body, .. } => {
                // Effects not yet implemented
                self.emit_expr(body)
            }

            // CPS expressions
            FlatExpr::AppCont { func, args, cont } => {
                let func_name = self.get_var_name(*func);
                let cont_name = self.get_var_name(*cont);
                let args_str: Vec<String> = args.iter().map(|a| self.get_var_name(*a)).collect();

                if func_name.starts_with("fn_") {
                    let all_args = std::iter::once("NULL".to_string())
                        .chain(args_str)
                        .chain(std::iter::once(cont_name))
                        .collect::<Vec<_>>();
                    format!("{}({})", func_name, all_args.join(", "))
                } else {
                    let mut result = func_name;
                    for arg_name in args_str {
                        result = format!("gn_apply({}, {})", result, arg_name);
                    }
                    format!("gn_apply({}, {})", result, cont_name)
                }
            }

            FlatExpr::Resume { cont, value } => {
                let cont_name = self.get_var_name(*cont);
                let value_name = self.get_var_name(*value);
                format!("gn_resume_multi({}, {})", cont_name, value_name)
            }

            FlatExpr::CaptureK { effect, op, args, cont, .. } => {
                let args_str: Vec<String> = args.iter().map(|a| self.get_var_name(*a)).collect();
                let cont_name = self.get_var_name(*cont);
                let n_args = args.len();

                let perform_call = if args.is_empty() {
                    format!("gn_perform({}, {}, 0, NULL, {})", effect, op, cont_name)
                } else {
                    format!(
                        "gn_perform({}, {}, {}, (gn_value[]){{{}}}, {})",
                        effect, op, n_args, args_str.join(", "), cont_name
                    )
                };

                writeln!(self.function_defs, "{}return {};", self.pad(), perform_call).unwrap();
                "GN_UNIT /* unreachable */".to_string()
            }

            FlatExpr::WithHandler { effect, handler, body, outer_cont, .. } => {
                let outer_k = self.get_var_name(*outer_cont);
                let return_handler = self.get_var_name(handler.return_handler);
                let handler_var = self.fresh_var(Some("handler"));
                let n_ops = handler.op_handlers.len();

                // Sort op handlers by op_id to ensure ops[i] handles operation i
                let mut sorted_ops: Vec<_> = handler.op_handlers.iter().collect();
                sorted_ops.sort_by_key(|op| op.op);

                let op_handlers_str: Vec<String> = sorted_ops
                    .iter()
                    .map(|op| self.get_var_name(op.handler_fn))
                    .collect();

                writeln!(
                    self.function_defs,
                    "{}gn_value {}_ops[] = {{{}}};",
                    self.pad(), handler_var, op_handlers_str.join(", ")
                ).unwrap();

                writeln!(
                    self.function_defs,
                    "{}gn_handler* {} = gn_create_handler({}, {}, {}, {}_ops, {});",
                    self.pad(), handler_var, effect, return_handler, n_ops, handler_var, outer_k
                ).unwrap();

                writeln!(
                    self.function_defs,
                    "{}gn_push_handler({});",
                    self.pad(), handler_var
                ).unwrap();

                let body_result = self.emit_expr(body);

                writeln!(
                    self.function_defs,
                    "{}return {};",
                    self.pad(), body_result
                ).unwrap();

                "GN_UNIT /* handler body returned */".to_string()
            }
        }
    }

    fn emit_atom(&mut self, atom: &FlatAtom) -> String {
        match atom {
            FlatAtom::Var(var) => {
                let name = self.get_var_name(*var);
                if let Some(arity) = self.func_arities.get(var).copied()
                    .or_else(|| self.func_name_arities.get(&name).copied())
                {
                    if arity == 0 {
                        return format!("{}(NULL)", name);
                    } else {
                        return match arity {
                            1 => format!("gn_make_closure1((void*){})", name),
                            2 => format!("gn_make_closure2((void*){})", name),
                            _ => format!("gn_make_closure((void*){}, {}, 0, NULL)", name, arity),
                        };
                    }
                }
                name
            }
            FlatAtom::Lit(lit) => emit_literal(lit),
            FlatAtom::Alloc { tag, ctor_name, fields, .. } => {
                let fields_str: Vec<String> = fields.iter().map(|f| self.get_var_name(*f)).collect();
                let name = ctor_name.as_deref().unwrap_or("anon");
                if fields.is_empty() {
                    format!("GN_CTOR({}, 0) /* {} */", tag, name)
                } else {
                    format!(
                        "gn_alloc({}, {}, (gn_value[]){{{}}})",
                        tag, fields.len(), fields_str.join(", ")
                    )
                }
            }
            FlatAtom::PrimOp { op, args } => emit_primop(op, args, &self.var_names),
            FlatAtom::MakeClosure { func, arity, captures, .. } => {
                let c_name = format!("fn_{}", mangle_name(func));
                if captures.is_empty() {
                    match arity {
                        1 => format!("gn_make_closure1((void*){})", c_name),
                        2 => format!("gn_make_closure2((void*){})", c_name),
                        _ => format!("gn_make_closure((void*){}, {}, 0, NULL)", c_name, arity),
                    }
                } else {
                    let capture_names: Vec<String> = captures.iter().map(|v| self.get_var_name(*v)).collect();
                    let captures_array = format!("(gn_value[]){{{}}}", capture_names.join(", "));
                    format!(
                        "gn_make_closure((void*){}, {}, {}, {})",
                        c_name, arity, captures.len(), captures_array
                    )
                }
            }
            FlatAtom::Call { func, args } => {
                let func_name = self.get_var_name(*func);
                let args_str: Vec<String> = args.iter().map(|a| self.get_var_name(*a)).collect();
                if func_name.starts_with("fn_") || func_name.starts_with("gn_") {
                    format!("{}({})", func_name, args_str.join(", "))
                } else {
                    let mut result = func_name;
                    for arg in &args_str {
                        result = format!("gn_apply({}, {})", result, arg);
                    }
                    result
                }
            }
        }
    }

    fn emit_case(&mut self, scrutinee: VarId, alts: &[FlatAlt], default: Option<&FlatExpr>) -> String {
        let result_var = self.fresh_var(Some("case_result"));
        let scrut_name = self.get_var_name(scrutinee);

        writeln!(self.function_defs, "{}gn_value {};", self.pad(), result_var).unwrap();
        writeln!(self.function_defs, "{}switch (GN_TAG({})) {{", self.pad(), scrut_name).unwrap();

        for alt in alts {
            let tag_name = alt.tag_name.as_deref().unwrap_or("?");
            writeln!(
                self.function_defs,
                "{}case {}: /* {} */ {{",
                self.pad(), alt.tag, tag_name
            ).unwrap();

            self.indent += 1;

            // Bind fields
            for (i, binder) in alt.binders.iter().enumerate() {
                let hint = alt.binder_hints.get(i).and_then(|h| h.as_deref());
                let var_name = self.fresh_var(hint);
                self.var_names.insert(*binder, var_name.clone());
                writeln!(
                    self.function_defs,
                    "{}gn_value {} = GN_FIELD({}, {});",
                    self.pad(), var_name, scrut_name, i
                ).unwrap();
            }

            let body_expr = self.emit_expr(&alt.body);
            writeln!(self.function_defs, "{}{} = {};", self.pad(), result_var, body_expr).unwrap();
            writeln!(self.function_defs, "{}break;", self.pad()).unwrap();

            self.indent -= 1;
            writeln!(self.function_defs, "{}}}", self.pad()).unwrap();
        }

        // Default case
        writeln!(self.function_defs, "{}default: {{", self.pad()).unwrap();
        self.indent += 1;
        if let Some(def) = default {
            let def_expr = self.emit_expr(def);
            writeln!(self.function_defs, "{}{} = {};", self.pad(), result_var, def_expr).unwrap();
        } else {
            writeln!(self.function_defs, "{}gn_panic(\"non-exhaustive match\");", self.pad()).unwrap();
            writeln!(self.function_defs, "{}{} = GN_UNIT;", self.pad(), result_var).unwrap();
        }
        writeln!(self.function_defs, "{}break;", self.pad()).unwrap();
        self.indent -= 1;
        writeln!(self.function_defs, "{}}}", self.pad()).unwrap();

        writeln!(self.function_defs, "{}}}", self.pad()).unwrap();

        result_var
    }

    fn get_var_name(&self, var: VarId) -> String {
        self.var_names
            .get(&var)
            .cloned()
            .unwrap_or_else(|| format!("v{}", var.0))
    }

    fn fresh_var(&mut self, hint: Option<&str>) -> String {
        let name = if let Some(h) = hint {
            format!("{}_{}", mangle_name(h), self.name_counter)
        } else {
            format!("tmp_{}", self.name_counter)
        };
        self.name_counter += 1;
        name
    }

    fn pad(&self) -> String {
        "    ".repeat(self.indent)
    }
}

// ============================================================================
// Helpers
// ============================================================================

fn emit_literal(lit: &CoreLit) -> String {
    match lit {
        CoreLit::Int(n) => format!("GN_INT({})", n),
        CoreLit::Float(f) => format!("gn_float({})", f),
        CoreLit::String(s) => format!("gn_string(\"{}\")", escape_string(s)),
        CoreLit::Char(c) => format!("GN_CHAR({})", *c as u32),
        CoreLit::Bool(true) => "GN_TRUE".to_string(),
        CoreLit::Bool(false) => "GN_FALSE".to_string(),
        CoreLit::Unit => "GN_UNIT".to_string(),
    }
}

fn emit_primop(op: &PrimOp, args: &[VarId], var_names: &HashMap<VarId, String>) -> String {
    let get_name = |v: &VarId| var_names.get(v).cloned().unwrap_or_else(|| format!("v{}", v.0));
    let args_str: Vec<String> = args.iter().map(get_name).collect();

    match op {
        PrimOp::IntAdd => format!("GN_INT_ADD({}, {})", args_str[0], args_str[1]),
        PrimOp::IntSub => format!("GN_INT_SUB({}, {})", args_str[0], args_str[1]),
        PrimOp::IntMul => format!("GN_INT_MUL({}, {})", args_str[0], args_str[1]),
        PrimOp::IntDiv => format!("GN_INT_DIV({}, {})", args_str[0], args_str[1]),
        PrimOp::IntMod => format!("GN_INT_MOD({}, {})", args_str[0], args_str[1]),
        PrimOp::IntNeg => format!("GN_INT_NEG({})", args_str[0]),
        PrimOp::FloatAdd => format!("gn_float_add({}, {})", args_str[0], args_str[1]),
        PrimOp::FloatSub => format!("gn_float_sub({}, {})", args_str[0], args_str[1]),
        PrimOp::FloatMul => format!("gn_float_mul({}, {})", args_str[0], args_str[1]),
        PrimOp::FloatDiv => format!("gn_float_div({}, {})", args_str[0], args_str[1]),
        PrimOp::FloatNeg => format!("gn_float_neg({})", args_str[0]),
        PrimOp::IntEq => format!("GN_INT_EQ({}, {})", args_str[0], args_str[1]),
        PrimOp::IntNe => format!("GN_INT_NE({}, {})", args_str[0], args_str[1]),
        PrimOp::IntLt => format!("GN_INT_LT({}, {})", args_str[0], args_str[1]),
        PrimOp::IntLe => format!("GN_INT_LE({}, {})", args_str[0], args_str[1]),
        PrimOp::IntGt => format!("GN_INT_GT({}, {})", args_str[0], args_str[1]),
        PrimOp::IntGe => format!("GN_INT_GE({}, {})", args_str[0], args_str[1]),
        PrimOp::FloatEq => format!("gn_float_eq({}, {})", args_str[0], args_str[1]),
        PrimOp::FloatNe => format!("gn_float_ne({}, {})", args_str[0], args_str[1]),
        PrimOp::FloatLt => format!("gn_float_lt({}, {})", args_str[0], args_str[1]),
        PrimOp::FloatLe => format!("gn_float_le({}, {})", args_str[0], args_str[1]),
        PrimOp::FloatGt => format!("gn_float_gt({}, {})", args_str[0], args_str[1]),
        PrimOp::FloatGe => format!("gn_float_ge({}, {})", args_str[0], args_str[1]),
        PrimOp::BoolAnd => format!("GN_BOOL_AND({}, {})", args_str[0], args_str[1]),
        PrimOp::BoolOr => format!("GN_BOOL_OR({}, {})", args_str[0], args_str[1]),
        PrimOp::BoolNot => format!("GN_BOOL_NOT({})", args_str[0]),
        PrimOp::StringConcat => format!("gn_string_concat({}, {})", args_str[0], args_str[1]),
        PrimOp::StringLength => format!("gn_string_length({})", args_str[0]),
        PrimOp::StringEq => format!("gn_string_eq({}, {})", args_str[0], args_str[1]),
        PrimOp::IntToFloat => format!("gn_int_to_float({})", args_str[0]),
        PrimOp::FloatToInt => format!("gn_float_to_int({})", args_str[0]),
        PrimOp::IntToString => format!("gn_int_to_string({})", args_str[0]),
        PrimOp::FloatToString => format!("gn_float_to_string({})", args_str[0]),
        PrimOp::CharToInt => format!("GN_CHAR_TO_INT({})", args_str[0]),
        PrimOp::IntToChar => format!("GN_INT_TO_CHAR({})", args_str[0]),
        PrimOp::TupleGet(n) => format!("GN_FIELD({}, {})", args_str[0], n),
        PrimOp::ListCons => format!("gn_list_cons({}, {})", args_str[0], args_str[1]),
        PrimOp::ListHead => format!("gn_list_head({})", args_str[0]),
        PrimOp::ListTail => format!("gn_list_tail({})", args_str[0]),
        PrimOp::ListIsEmpty => format!("gn_list_is_empty({})", args_str[0]),
    }
}

fn mangle_name(name: &str) -> String {
    let mut result = String::new();
    for c in name.chars() {
        match c {
            'a'..='z' | 'A'..='Z' | '0'..='9' => result.push(c),
            '_' => result.push('_'),
            '\'' => result.push_str("_prime"),
            _ => result.push_str(&format!("_u{:04x}_", c as u32)),
        }
    }
    result
}

/// Get the arity of a builtin function by name
fn get_builtin_arity(name: &str) -> usize {
    match name {
        // IO
        "io_print" | "print" => 1,
        "io_println" => 1,
        "io_read_line" => 1,

        // String operations
        "int_to_string" => 1,
        "char_to_string" => 1,
        "string_length" => 1,
        "string_concat" => 2,
        "string_eq" => 2,
        "string_split" => 2,
        "string_join" => 2,
        "string_substring" => 3,
        "string_index_of" => 2,
        "string_replace" => 3,
        "string_to_upper" => 1,
        "string_to_lower" => 1,
        "string_trim" => 1,
        "string_starts_with" => 2,
        "string_ends_with" => 2,
        "string_contains" => 2,
        "string_char_at" => 2,
        "string_to_chars" => 1,

        // Math
        "float_add" | "float_sub" | "float_mul" | "float_div" => 2,
        "float_neg" | "float_abs" | "float_sqrt" | "float_floor" | "float_ceil" => 1,
        "int_to_float" | "float_to_int" => 1,
        "float_to_string" => 1,

        // List
        "list_cons" => 2,
        "list_head" | "list_tail" | "list_is_empty" => 1,

        // Default - unknown builtin
        _ => 1,
    }
}

fn escape_string(s: &str) -> String {
    let mut result = String::new();
    for c in s.chars() {
        match c {
            '"' => result.push_str("\\\""),
            '\\' => result.push_str("\\\\"),
            '\n' => result.push_str("\\n"),
            '\r' => result.push_str("\\r"),
            '\t' => result.push_str("\\t"),
            c if c.is_ascii_graphic() || c == ' ' => result.push(c),
            c => result.push_str(&format!("\\x{:02x}", c as u32)),
        }
    }
    result
}

// ============================================================================
// Public API
// ============================================================================

/// Emit C code from a FlatProgram
pub fn emit_flat_c(program: &FlatProgram) -> String {
    let mut emitter = FlatEmitter::new();
    emitter.emit_program(program)
}
