-- =============================================================================
-- Pattern: Effect Handlers (Algebraic Effects)
-- =============================================================================
--
-- Effect handlers are a principled way to structure programs with effects.
-- They generalize ALL the patterns we've seen:
-- - Exceptions = non-resumable effects
-- - State = resumable effects with threading
-- - Nondeterminism = effects that resume multiple times
-- - Generators = effects that yield values
--
-- Key insight: An "effect" is just calling shift with some operation.
-- A "handler" is the reset that interprets those operations.

-- =============================================================================
-- Helpers (must be defined before use)
-- =============================================================================

let reverse xs =
    let go acc remaining =
        match remaining with
        | [] -> acc
        | x :: rest -> go (x :: acc) rest
        end
    in
    go [] xs

type Result a e = Ok a | Err e

type Option a = Some a | None

-- =============================================================================
-- Part 1: The Effect Handler Pattern
-- =============================================================================

-- An effect operation is identified by a tag and carries arguments
-- The handler receives the operation and decides how to handle it

-- General structure:
--   perform : operation -> result
--   handle computation { operation -> handler_code }

-- In terms of shift/reset:
--   perform op = shift (fun k -> Op op k)
--   handle comp handlers = reset (
--       let result = comp () in
--       Return result
--   ) |> match_handlers

-- =============================================================================
-- Part 2: Exception Effect
-- =============================================================================

-- ExnEff needs two type parameters:
-- 'a' is the "answer type" - what throw_exn returns (polymorphic for flexibility)
-- 'b' is the "result type" - what successful computations return
type ExnEff a b =
    | ExnReturn b
    | ExnThrow String (a -> ExnEff a b)  -- continuation is ignored by handler

-- throw_exn returns a polymorphic 'a', allowing it to be used in any context
let throw_exn msg =
    shift (fun k -> ExnThrow msg k)

let handle_exn comp handler =
    let interpret result =
        match result with
        | ExnReturn x -> x
        | ExnThrow msg _ -> handler msg
        end
    in
    interpret (reset (ExnReturn (comp ())))

-- Example
let exn_example () =
    handle_exn
        (fun () ->
            let x = 10 in
            if x > 5 then throw_exn "too big" else x * 2
        )
        (fun msg ->
            print ("Caught: " ++ msg);
            0
        )

-- =============================================================================
-- Part 3: State Effect
-- =============================================================================

type StateOp s =
    | Get
    | Put s

type StateEff s a =
    | StateReturn a
    | StateOp (StateOp s) (s -> StateEff s a)  -- Put ignores the "returned" value

let state_get () =
    shift (fun k -> StateOp Get k)

let state_put s =
    shift (fun k -> StateOp (Put s) (fun _ -> k ()))

let handle_state comp initial =
    let interpret eff state =
        match eff with
        | StateReturn x -> (x, state)
        | StateOp Get k -> interpret (k state) state
        | StateOp (Put new_state) k -> interpret (k new_state) new_state
        end
    in
    interpret (reset (StateReturn (comp ()))) initial

-- Example
let state_example () =
    let (result, final_state) = handle_state
        (fun () ->
            let x = state_get () in
            state_put (x + 10);
            let y = state_get () in
            state_put (y * 2);
            state_get ()
        )
        5
    in
    print ("Result: " ++ int_to_string result);      -- 30
    print ("Final: " ++ int_to_string final_state)   -- 30

-- =============================================================================
-- Part 4: Nondeterminism Effect
-- =============================================================================

-- NOTE: NondetFail is a separate constructor (not inside NondetOp) because
-- Fail doesn't need a continuation - the handler just returns [].
-- If we shared the continuation type with Choose, it would constrain
-- the result type to match Choose's Int element type.
type NondetEff a =
    | NondetReturn a
    | NondetChoose (List Int) (Int -> NondetEff a)
    | NondetFail

let choose_eff xs =
    shift (fun k -> NondetChoose xs k)

let fail_eff () =
    shift (fun _k -> NondetFail)

-- NOTE: Full nondeterminism handler needs let-in-match-arm support (gneiss-lang-ebe)
-- Using helper function pattern to work around parser limitation
let nondet_handle_choose interpret xs k =
    match xs with
    | [] -> []
    | x :: _ -> interpret (k x)
    end

let map f lst =
  match lst with
  | [] -> []
  | hd :: rest -> f hd :: map f rest
  end

let concat xs =
    match xs with
    | [] -> []
    | x :: rest -> x ++ concat rest
    end

let concat_map f xs =
    concat (map f xs)

-- let handle_nondet comp =
--    let interpret eff =
--        match eff with
--        | NondetReturn x -> [x]
--        | NondetFail -> []
--        | NondetChoose xs k -> concat_map (fun x -> interpret (k x)) xs
--        end
--    in
--    interpret (reset (NondetReturn (comp ())))

let handle_nondet comp =
    let interpret eff =
        match eff with
        | NondetReturn x -> [x]
        | NondetFail -> []
        | NondetChoose xs k -> nondet_handle_choose interpret xs k
        end
    in
    interpret (reset (NondetReturn (comp ())))

-- Example: Pythagorean triples
let nondet_example () =
    handle_nondet (fun () ->
        let a = choose_eff [1, 2, 3, 4, 5] in
        let b = choose_eff [1, 2, 3, 4, 5] in
        let c = choose_eff [1, 2, 3, 4, 5] in
        if a*a + b*b == c*c && a <= b then (a, b, c)
        else fail_eff ()
    )

-- =============================================================================
-- Part 5: Yield Effect (Generators)
-- =============================================================================

type YieldEff a b =
    | YieldReturn b
    | Yield a (() -> YieldEff a b)

let yield_eff x =
    shift (fun k -> Yield x k)

-- Collect all yielded values
let handle_yield_collect comp =
    let interpret eff acc =
        match eff with
        | YieldReturn _ -> reverse acc
        | Yield x k -> interpret (k ()) (x :: acc)
        end
    in
    interpret (reset (YieldReturn (comp ()))) []

-- Transform yielded values
let handle_yield_map f comp =
    let interpret eff =
        match eff with
        | YieldReturn x -> YieldReturn x
        | Yield x k -> Yield (f x) (fun () -> interpret (k ()))
        end
    in
    interpret (reset (YieldReturn (comp ())))

-- Example
let yield_example () =
    handle_yield_collect (fun () ->
        yield_eff 1;
        yield_eff 2;
        yield_eff 3;
        ()
    )

-- =============================================================================
-- Part 6: Composing Effects (Effect Stacks)
-- =============================================================================

-- Effects can be layered! State + Exceptions:

type StateExnEff s a =
    | SEReturn a
    | SEGet (s -> StateExnEff s a)
    | SEPut s (() -> StateExnEff s a)
    | SEThrow String

let se_get () = shift (fun k -> SEGet k)
let se_put s = shift (fun k -> SEPut s k)
let se_throw msg = shift (fun _k -> SEThrow msg)

let handle_state_exn comp initial =
    let interpret eff state =
        match eff with
        | SEReturn x -> Ok (x, state)
        | SEGet k -> interpret (k state) state
        | SEPut new_state k -> interpret (k ()) new_state
        | SEThrow msg -> Err msg
        end
    in
    interpret (reset (SEReturn (comp ()))) initial

-- Example: Stateful computation that might fail
let state_exn_example () =
    let result = handle_state_exn
        (fun () ->
            let x = se_get () in
            if x < 0 then se_throw "negative state!"
            else (
                se_put (x + 1);
                se_get ()
            )
        )
        10
    in
    match result with
    | Ok (value, state) -> print ("Success: " ++ int_to_string value)
    | Err msg -> print ("Error: " ++ msg)
    end

-- =============================================================================
-- Part 7: Reader Effect (Environment)
-- =============================================================================

type ReaderEff r a =
    | ReaderReturn a
    | Ask (r -> ReaderEff r a)
    | Local (r -> r) (() -> ReaderEff r a) (ReaderEff r a -> ReaderEff r a)

let ask () = shift (fun k -> Ask k)

let handle_reader comp env =
    let interpret eff =
        match eff with
        | ReaderReturn x -> x
        | Ask k -> interpret (k env)
        end
    in
    interpret (reset (ReaderReturn (comp ())))

-- Example: Configuration reader (using tuple as config: (debug, max_depth))
let reader_example () =
    let config = (true, 10) in
    handle_reader (fun () ->
        let (debug, max_depth) = ask () in
        if debug then print "Debug mode enabled" else ();
        max_depth
    ) config

-- =============================================================================
-- Part 8: The Power of Handlers - Different Interpretations
-- =============================================================================

-- The SAME effectful computation can be interpreted differently!

let my_computation () =
    let x = choose_eff [1, 2] in
    let y = choose_eff [10, 20] in
    x + y

-- Interpretation 1: Collect all results
let all_results () =
    handle_nondet my_computation
    -- [11, 21, 12, 22]

-- Interpretation 2: Take only first (with a different handler)
let nondet_first_handle_choose interpret xs k =
    match xs with
    | [] -> None
    | x :: _ -> interpret (k x)
    end

let handle_nondet_first comp =
    let interpret eff =
        match eff with
        | NondetReturn x -> Some x
        | NondetFail -> None
        | NondetChoose xs k -> nondet_first_handle_choose interpret xs k
        end
    in
    interpret (reset (NondetReturn (comp ())))

let first_result () =
    handle_nondet_first my_computation
    -- Some 11

let main () =
    print "=== Exception Effect ===";
    print (exn_example ());
    
    print "";
    print "=== State Effect ===";
    state_example ();
    
    print "";
    print "=== Nondeterminism Effect ===";
    print (nondet_example ());
    
    print "";
    print "=== Yield Effect ===";
    print (yield_example ());
    
    print "";
    print "=== Composed Effects ===";
    state_exn_example ();
    
    print "";
    print "=== Same Computation, Different Handlers ===";
    print "All results:";
    print (all_results ());
    print "First result:";
    print (first_result ())
