-- Gneiss Prelude
-- Auto-imported into every program

-- Core sum types
type Option a = | Some a | None
type Result e a = | Ok a | Err e

-- I/O Error type
type IoError =
    | NotFound
    | PermissionDenied
    | ConnectionRefused
    | ConnectionReset
    | BrokenPipe
    | TimedOut
    | AddrInUse
    | AddrNotAvailable
    | InvalidInput String
    | IoOther String

-- ============================================================================
-- Show Trait
-- ============================================================================
-- Convert values to their string representation

trait Show a =
    val show : a -> String
end

impl Show for Int =
    let show n = int_to_string n
end

impl Show for String =
    let show s = s
end

impl Show for Bool =
    let show b = if b then "true" else "false"
end

impl Show for Char =
    let show c = char_to_string c
end

impl Show for () =
    let show _ = "()"
end

impl Show for (Option a) where a : Show =
    let show opt =
        match opt with
        | Some x -> "Some(" ++ show x ++ ")"
        | None -> "None"
        end
end

impl Show for (Result e a) where e : Show, a : Show =
    let show res =
        match res with
        | Ok x -> "Ok(" ++ show x ++ ")"
        | Err e -> "Err(" ++ show e ++ ")"
        end
end

-- Note: Show for List is defined after map is available

-- ============================================================================
-- Standard Effects (import from Effect/ modules)
-- ============================================================================
--
-- Effects are now defined in separate modules with handlers:
--
--   import Effect/State    -- State s: get, put
--   import Effect/Reader   -- Reader r: ask
--   import Effect/Writer   -- Writer w: tell
--   import Effect/Exn      -- Exn e: raise (polymorphic return)
--   import Effect/Abort    -- Abort: abort (early exit)
--   import Effect/NonDet   -- NonDet: choose, fail (backtracking)
--   import Effect/IO       -- IO: print_line, read_line
--   import Effect/Async    -- Async: fork, join, yield
--
-- Each module provides the effect definition and standard handlers.
-- Example:
--
--   import Effect/State
--
--   let counter () =
--       let x = perform State.get () in
--       perform State.put (x + 1)
--
--   let result = State.run 0 counter
--
-- ============================================================================

-- Identity combinator
let id x = x

-- Constant combinator (returns first argument, ignores second)
let const x _ = x

-- Flip argument order
let flip f x y = f y x

-- List operations
let rec map f xs =
    match xs with
    | [] -> []
    | x :: rest -> f x :: map f rest
    end

let rec filter p xs =
    match xs with
    | [] -> []
    | x :: rest -> if p x then x :: filter p rest else filter p rest
    end

let rec foldl f acc xs =
    match xs with
    | [] -> acc
    | x :: rest -> foldl f (f acc x) rest
    end

let rec foldr f acc xs =
    match xs with
    | [] -> acc
    | x :: rest -> f x (foldr f acc rest)
    end

let null xs = match xs with | [] -> true | _ -> false end
let rec length xs = match xs with | [] -> 0 | _ :: rest -> 1 + length rest end
let rec reverse xs = foldl (fun acc x -> x :: acc) [] xs
let rec list_append xs ys = match xs with | [] -> ys | x :: rest -> x :: list_append rest ys end
let head xs = match xs with | [] -> None | x :: _ -> Some x end
let tail xs = match xs with | [] -> None | _ :: rest -> Some rest end

-- Show for List (defined here since it needs map)
impl Show for (List a) where a : Show =
    let show xs = "[" ++ string_join ", " (map show xs) ++ "]"
end

-- ============================================================================
-- Print function (uses Show trait and IO effect)
-- ============================================================================
-- print : a -> () { IO } where a : Show
-- Converts any showable value to a string and prints it to stdout.
let print x = io_print (show x)

-- println : a -> () { IO } where a : Show
-- Like print, but adds a newline at the end.
let println x = io_print (show x ++ "\n")

-- read_line : () -> String { IO }
-- Reads a line from stdin (wrapper around io_read_line).
let read_line () = io_read_line ()

let rec drop_while p xs =
    match xs with
    | [] -> []
    | x :: rest -> if p x then drop_while p rest else xs
    end

-- Range generation
-- range start end generates [start, start+1, ..., end-1] (exclusive end)
let rec range_helper start end_ acc =
    if start >= end_ then reverse acc
    else range_helper (start + 1) end_ (start :: acc)

let range start end_ = range_helper start end_ []

-- range_inclusive start end generates [start, start+1, ..., end] (inclusive end)
let range_inclusive start end_ = range start (end_ + 1)

-- String operations
-- Note: string_to_lower, string_to_upper, string_trim, string_split, string_join
-- are now native builtins for performance

let string_contains needle haystack =
    match string_index_of needle haystack with
    | Some _ -> true
    | None -> false
    end

let string_starts_with prefix s =
    string_substring 0 (string_length prefix) s == prefix

let string_ends_with suffix s =
    let slen = string_length s in
    let suflen = string_length suffix in
    if suflen > slen then false
    else string_substring (slen - suflen) slen s == suffix

let string_replace from to s = string_join to (string_split from s)

-- ============================================================================
-- Additional List operations
-- ============================================================================

-- take n xs: Take the first n elements from a list
let rec take n xs =
    if n <= 0 then []
    else match xs with
        | [] -> []
        | x :: rest -> x :: take (n - 1) rest
    end

-- drop n xs: Drop the first n elements from a list
let rec drop n xs =
    if n <= 0 then xs
    else match xs with
        | [] -> []
        | _ :: rest -> drop (n - 1) rest
    end

-- nth n xs: Get the element at index n (0-based), returns Option
let rec nth n xs =
    match xs with
    | [] -> None
    | x :: rest -> if n == 0 then Some x else nth (n - 1) rest
    end

-- find p xs: Find the first element satisfying predicate p
let rec find p xs =
    match xs with
    | [] -> None
    | x :: rest -> if p x then Some x else find p rest
    end

-- zip xs ys: Combine two lists into a list of pairs
let rec zip xs ys =
    match (xs, ys) with
    | ([], _) -> []
    | (_, []) -> []
    | (x :: xrest, y :: yrest) -> (x, y) :: zip xrest yrest
    end

-- zipWith f xs ys: Combine two lists using a function
let rec zipWith f xs ys =
    match (xs, ys) with
    | ([], _) -> []
    | (_, []) -> []
    | (x :: xrest, y :: yrest) -> f x y :: zipWith f xrest yrest
    end

-- unzip xys: Split a list of pairs into two lists
let unzip xys =
    let rec go xs ys pairs =
        match pairs with
        | [] -> (reverse xs, reverse ys)
        | (x, y) :: rest -> go (x :: xs) (y :: ys) rest
        end
    in go [] [] xys

-- partition p xs: Split list into (elements satisfying p, elements not satisfying p)
let partition p xs =
    let rec go yes no lst =
        match lst with
        | [] -> (reverse yes, reverse no)
        | x :: rest ->
            if p x then go (x :: yes) no rest
            else go yes (x :: no) rest
        end
    in go [] [] xs

-- intersperse sep xs: Insert separator between elements
let rec intersperse sep xs =
    match xs with
    | [] -> []
    | [x] -> [x]
    | x :: rest -> x :: sep :: intersperse sep rest
    end

-- concat xss: Flatten a list of lists
let concat xss = foldr (fun xs acc -> xs ++ acc) [] xss

-- concatMap f xs: Map then flatten (flatMap/bind for lists)
let concatMap f xs = concat (map f xs)

-- all p xs: Check if all elements satisfy predicate
let rec all p xs =
    match xs with
    | [] -> true
    | x :: rest -> if p x then all p rest else false
    end

-- any p xs: Check if any element satisfies predicate
let rec any p xs =
    match xs with
    | [] -> false
    | x :: rest -> if p x then true else any p rest
    end

-- sum xs: Sum of a list of integers
let sum xs = foldl (fun acc x -> acc + x) 0 xs

-- product xs: Product of a list of integers
let product xs = foldl (fun acc x -> acc * x) 1 xs

-- last xs: Get the last element of a list
let rec last xs =
    match xs with
    | [] -> None
    | [x] -> Some x
    | _ :: rest -> last rest
    end

-- init xs: Get all elements except the last
let init xs =
    let rec go acc lst =
        match lst with
        | [] -> None
        | [_] -> Some (reverse acc)
        | x :: rest -> go (x :: acc) rest
        end
    in go [] xs

-- replicate n x: Create a list of n copies of x
let rec replicate n x =
    if n <= 0 then []
    else x :: replicate (n - 1) x

-- take_while p xs: Take elements while predicate holds
let rec take_while p xs =
    match xs with
    | [] -> []
    | x :: rest -> if p x then x :: take_while p rest else []
    end

-- elem x xs: Check if x is in the list (uses ==)
let rec elem x xs =
    match xs with
    | [] -> false
    | y :: rest -> if x == y then true else elem x rest
    end

-- ============================================================================
-- Tuple operations
-- ============================================================================

-- fst: Get the first element of a pair
let fst pair = match pair with | (x, _) -> x end

-- snd: Get the second element of a pair
let snd pair = match pair with | (_, y) -> y end

-- swap: Swap the elements of a pair
let swap pair = match pair with | (x, y) -> (y, x) end

-- ============================================================================
-- Math operations
-- ============================================================================

-- abs: Absolute value
let abs n = if n < 0 then 0 - n else n

-- negate: Negate a number
let negate n = 0 - n

-- min: Minimum of two values
let min a b = if a < b then a else b

-- max: Maximum of two values
let max a b = if a > b then a else b

-- clamp lo hi x: Clamp x to the range [lo, hi]
let clamp lo hi x =
    if x < lo then lo
    else if x > hi then hi
    else x

-- ============================================================================
-- String operations (additional)
-- ============================================================================

-- lines: Split a string on newlines
let lines s = string_split "\n" s

-- unlines: Join strings with newlines
let unlines xs = string_join "\n" xs

-- words: Split a string on whitespace (simple version using spaces)
let words s = filter (fun w -> string_length w > 0) (string_split " " s)

-- unwords: Join strings with spaces
let unwords xs = string_join " " xs

-- ============================================================================
-- Option operations
-- ============================================================================

-- map_option f opt: Apply f to the value inside Some, or return None
let map_option f opt =
    match opt with
    | None -> None
    | Some x -> Some (f x)
    end

-- and_then opt f: Chain Option computations (flatMap/bind for Option)
let and_then opt f =
    match opt with
    | None -> None
    | Some x -> f x
    end

-- unwrap_or default opt: Get the value or a default
let unwrap_or default opt =
    match opt with
    | None -> default
    | Some x -> x
    end

-- is_some opt: Check if Option contains a value
let is_some opt = match opt with | Some _ -> true | None -> false end

-- is_none opt: Check if Option is empty
let is_none opt = match opt with | None -> true | Some _ -> false end

-- ============================================================================
-- Result operations
-- ============================================================================

-- map_result f res: Apply f to Ok value, pass through Err
let map_result f res =
    match res with
    | Err e -> Err e
    | Ok x -> Ok (f x)
    end

-- map_err f res: Apply f to Err value, pass through Ok
let map_err f res =
    match res with
    | Ok x -> Ok x
    | Err e -> Err (f e)
    end

-- and_then_result res f: Chain Result computations
let and_then_result res f =
    match res with
    | Err e -> Err e
    | Ok x -> f x
    end

-- unwrap_or_result default res: Get Ok value or default
let unwrap_or_result default res =
    match res with
    | Err _ -> default
    | Ok x -> x
    end

-- is_ok res: Check if Result is Ok
let is_ok res = match res with | Ok _ -> true | Err _ -> false end

-- is_err res: Check if Result is Err
let is_err res = match res with | Err _ -> true | Ok _ -> false end

-- ============================================================================
-- Testing / Assertions
-- ============================================================================

-- panic : String -> a
-- Exit the program with an error message. Never returns.
let panic msg = panic_str msg

-- Unsafe list operations that panic on empty list (for when list is known non-empty)
let head_unsafe xs =
    match xs with
    | [] -> panic "head of empty list"
    | x :: _ -> x
    end

let tail_unsafe xs =
    match xs with
    | [] -> panic "tail of empty list"
    | _ :: rest -> rest
    end

-- assert_eq : a -> a -> () where a : Eq, Show
-- Assert that two values are equal. Panics with a message showing both values if not.
let assert_eq x y =
    if x == y then ()
    else panic ("assertion failed: " ++ show x ++ " != " ++ show y)
