//! Typed Abstract Syntax Tree
//!
//! This module defines a typed AST where each expression node is annotated
//! with its inferred type. This enables:
//! 1. Tests that inspect types of sub-expressions
//! 2. Verification that constraints are properly attached
//! 3. Foundation for future compilation passes (codegen needs types)

use crate::ast::{BinOp, Ident, Literal, Span, UnaryOp};
use crate::types::{Pred, Scheme, Type};
use std::rc::Rc;

// ============================================================================
// Typed Expressions
// ============================================================================

/// A typed expression - an expression annotated with its inferred type
#[derive(Debug, Clone)]
pub struct TExpr {
    /// The expression kind
    pub kind: TExprKind,
    /// The inferred type of this expression
    pub ty: Type,
    /// Source span for error reporting
    pub span: Span,
}

impl TExpr {
    pub fn new(kind: TExprKind, ty: Type, span: Span) -> Self {
        Self { kind, ty, span }
    }
}

/// Typed expression kinds - mirrors ExprKind but with typed children
#[derive(Debug, Clone)]
pub enum TExprKind {
    // Literals
    Lit(Literal),

    // Variable reference - includes the scheme it was instantiated from
    Var {
        name: Ident,
        /// The scheme this variable had before instantiation (for let-bound vars)
        scheme: Option<Scheme>,
        /// Predicates generated by instantiation (e.g., Show a when calling `show`)
        instantiated_preds: Vec<Pred>,
    },

    // Lambda
    Lambda {
        params: Vec<TPattern>,
        body: Rc<TExpr>,
    },

    // Application
    App {
        func: Rc<TExpr>,
        arg: Rc<TExpr>,
    },

    // Let binding - includes the generalized scheme for the bound variable
    Let {
        pattern: TPattern,
        /// The scheme assigned to the bound variable (may be polymorphic)
        scheme: Scheme,
        value: Rc<TExpr>,
        body: Option<Rc<TExpr>>,
    },

    // Recursive let bindings
    LetRec {
        bindings: Vec<TRecBinding>,
        body: Option<Rc<TExpr>>,
    },

    // If expression
    If {
        cond: Rc<TExpr>,
        then_branch: Rc<TExpr>,
        else_branch: Rc<TExpr>,
    },

    // Match expression
    Match {
        scrutinee: Rc<TExpr>,
        arms: Vec<TMatchArm>,
    },

    // Tuple
    Tuple(Vec<TExpr>),

    // List
    List(Vec<TExpr>),

    // Constructor application
    Constructor {
        name: Ident,
        args: Vec<TExpr>,
    },

    // Binary operator
    BinOp {
        op: BinOp,
        left: Rc<TExpr>,
        right: Rc<TExpr>,
    },

    // Unary operator
    UnaryOp {
        op: UnaryOp,
        operand: Rc<TExpr>,
    },

    // Sequencing
    Seq {
        first: Rc<TExpr>,
        second: Rc<TExpr>,
    },

    // ========================================================================
    // Concurrency primitives
    // ========================================================================
    Spawn(Rc<TExpr>),
    NewChannel,
    ChanSend {
        channel: Rc<TExpr>,
        value: Rc<TExpr>,
    },
    ChanRecv(Rc<TExpr>),
    Select {
        arms: Vec<TSelectArm>,
    },

    // ========================================================================
    // Algebraic Effects
    // ========================================================================
    Perform {
        effect: Ident,
        operation: Ident,
        args: Vec<TExpr>,
    },
    Handle {
        body: Rc<TExpr>,
        return_clause: THandlerReturn,
        handlers: Vec<THandlerArm>,
    },

    // ========================================================================
    // Records
    // ========================================================================
    Record {
        name: Ident,
        fields: Vec<(Ident, TExpr)>,
    },
    FieldAccess {
        record: Rc<TExpr>,
        field: Ident,
    },
    RecordUpdate {
        base: Rc<TExpr>,
        updates: Vec<(Ident, TExpr)>,
    },

    // Typed hole
    Hole,
}

// ============================================================================
// Typed Patterns
// ============================================================================

/// A typed pattern
#[derive(Debug, Clone)]
pub struct TPattern {
    pub kind: TPatternKind,
    /// The type this pattern matches against
    pub ty: Type,
    pub span: Span,
}

#[derive(Debug, Clone)]
pub enum TPatternKind {
    /// Variable binding
    Var(Ident),
    /// Wildcard _
    Wildcard,
    /// Literal pattern
    Lit(Literal),
    /// Constructor pattern
    Constructor {
        name: Ident,
        args: Vec<TPattern>,
    },
    /// Tuple pattern
    Tuple(Vec<TPattern>),
    /// List pattern [a, b, c]
    List(Vec<TPattern>),
    /// Cons pattern h :: t
    Cons {
        head: Box<TPattern>,
        tail: Box<TPattern>,
    },
    /// Record pattern { field1, field2 = pat }
    Record {
        name: Ident,
        fields: Vec<(Ident, Option<TPattern>)>,
    },
}

// ============================================================================
// Supporting structures
// ============================================================================

#[derive(Debug, Clone)]
pub struct TMatchArm {
    pub pattern: TPattern,
    pub guard: Option<TExpr>,
    pub body: TExpr,
}

#[derive(Debug, Clone)]
pub struct TSelectArm {
    pub channel: TExpr,
    pub pattern: TPattern,
    pub body: TExpr,
}

#[derive(Debug, Clone)]
pub struct THandlerReturn {
    pub pattern: TPattern,
    pub body: Box<TExpr>,
}

#[derive(Debug, Clone)]
pub struct THandlerArm {
    pub operation: Ident,
    pub params: Vec<TPattern>,
    pub continuation: Ident,
    pub body: Box<TExpr>,
}

#[derive(Debug, Clone)]
pub struct TRecBinding {
    pub name: Ident,
    /// The scheme for this recursive binding
    pub scheme: Scheme,
    pub params: Vec<TPattern>,
    pub body: TExpr,
}

// ============================================================================
// Typed Program
// ============================================================================

/// A typed program
#[derive(Debug, Clone)]
pub struct TProgram {
    pub items: Vec<TItem>,
}

/// A typed top-level item
#[derive(Debug, Clone)]
pub enum TItem {
    /// A typed declaration
    Decl(TDecl),
    /// Type declarations pass through unchanged (they don't have runtime values)
    TypeDecl {
        name: Ident,
        params: Vec<Ident>,
        constructors: Vec<(Ident, Vec<Type>)>,
    },
    /// Trait declarations
    TraitDecl {
        name: Ident,
        param: Ident,
        methods: Vec<(Ident, Scheme)>,
    },
    /// Instance declarations
    InstanceDecl {
        trait_name: Ident,
        for_type: Type,
        methods: Vec<(Ident, TExpr)>,
    },
    /// Effect declarations
    EffectDecl {
        name: Ident,
        operations: Vec<(Ident, Type)>,
    },
    /// Module declarations
    Module {
        name: Ident,
        items: Vec<TItem>,
    },
}

/// A typed declaration
#[derive(Debug, Clone)]
pub enum TDecl {
    /// Let binding at top level
    Let {
        pattern: TPattern,
        scheme: Scheme,
        value: TExpr,
    },
    /// Recursive let bindings at top level
    LetRec {
        bindings: Vec<TRecBinding>,
    },
}

// ============================================================================
// Utility functions for inspection
// ============================================================================

impl TExpr {
    /// Find a let-bound variable by name and return its scheme
    pub fn find_let_binding(&self, name: &str) -> Option<&Scheme> {
        match &self.kind {
            TExprKind::Let { pattern, scheme, body, .. } => {
                if let TPatternKind::Var(n) = &pattern.kind {
                    if n == name {
                        return Some(scheme);
                    }
                }
                if let Some(body) = body {
                    body.find_let_binding(name)
                } else {
                    None
                }
            }
            TExprKind::LetRec { bindings, body } => {
                for binding in bindings {
                    if binding.name == name {
                        return Some(&binding.scheme);
                    }
                }
                if let Some(body) = body {
                    body.find_let_binding(name)
                } else {
                    None
                }
            }
            TExprKind::Lambda { body, .. } => body.find_let_binding(name),
            TExprKind::App { func, arg } => {
                func.find_let_binding(name).or_else(|| arg.find_let_binding(name))
            }
            TExprKind::If { cond, then_branch, else_branch } => {
                cond.find_let_binding(name)
                    .or_else(|| then_branch.find_let_binding(name))
                    .or_else(|| else_branch.find_let_binding(name))
            }
            TExprKind::Match { scrutinee, arms } => {
                scrutinee.find_let_binding(name).or_else(|| {
                    arms.iter().find_map(|arm| arm.body.find_let_binding(name))
                })
            }
            TExprKind::Seq { first, second } => {
                first.find_let_binding(name).or_else(|| second.find_let_binding(name))
            }
            _ => None,
        }
    }

    /// Collect all variable references with their instantiated predicates
    pub fn collect_var_instantiations(&self) -> Vec<(&str, &[Pred])> {
        let mut result = Vec::new();
        self.collect_var_instantiations_inner(&mut result);
        result
    }

    fn collect_var_instantiations_inner<'a>(&'a self, result: &mut Vec<(&'a str, &'a [Pred])>) {
        match &self.kind {
            TExprKind::Var { name, instantiated_preds, .. } => {
                if !instantiated_preds.is_empty() {
                    result.push((name.as_str(), instantiated_preds.as_slice()));
                }
            }
            TExprKind::Lambda { body, .. } => body.collect_var_instantiations_inner(result),
            TExprKind::App { func, arg } => {
                func.collect_var_instantiations_inner(result);
                arg.collect_var_instantiations_inner(result);
            }
            TExprKind::Let { value, body, .. } => {
                value.collect_var_instantiations_inner(result);
                if let Some(body) = body {
                    body.collect_var_instantiations_inner(result);
                }
            }
            TExprKind::LetRec { bindings, body } => {
                for binding in bindings {
                    binding.body.collect_var_instantiations_inner(result);
                }
                if let Some(body) = body {
                    body.collect_var_instantiations_inner(result);
                }
            }
            TExprKind::If { cond, then_branch, else_branch } => {
                cond.collect_var_instantiations_inner(result);
                then_branch.collect_var_instantiations_inner(result);
                else_branch.collect_var_instantiations_inner(result);
            }
            TExprKind::Match { scrutinee, arms } => {
                scrutinee.collect_var_instantiations_inner(result);
                for arm in arms {
                    arm.body.collect_var_instantiations_inner(result);
                }
            }
            TExprKind::Seq { first, second } => {
                first.collect_var_instantiations_inner(result);
                second.collect_var_instantiations_inner(result);
            }
            TExprKind::Tuple(exprs) | TExprKind::List(exprs) => {
                for expr in exprs {
                    expr.collect_var_instantiations_inner(result);
                }
            }
            TExprKind::BinOp { left, right, .. } => {
                left.collect_var_instantiations_inner(result);
                right.collect_var_instantiations_inner(result);
            }
            _ => {}
        }
    }
}

// ============================================================================
// Validation: Check that all types are fully resolved
// ============================================================================

impl TProgram {
    /// Validate that the typed AST has no unresolved type or row variables.
    /// Returns a list of issues found, or empty vec if fully valid.
    pub fn validation_issues(&self) -> Vec<String> {
        let mut issues = Vec::new();
        for item in &self.items {
            item.collect_validation_issues(&mut issues);
        }
        issues
    }

    /// Returns true if the typed AST is fully resolved.
    pub fn is_valid(&self) -> bool {
        self.validation_issues().is_empty()
    }
}

impl TItem {
    fn collect_validation_issues(&self, issues: &mut Vec<String>) {
        match self {
            TItem::Decl(decl) => decl.collect_validation_issues(issues),
            TItem::TypeDecl { constructors, .. } => {
                for (_, arg_types) in constructors {
                    for ty in arg_types {
                        issues.extend(ty.validation_issues());
                    }
                }
            }
            TItem::TraitDecl { methods, .. } => {
                for (_, scheme) in methods {
                    issues.extend(scheme.ty.validation_issues());
                }
            }
            TItem::InstanceDecl { methods, .. } => {
                for (_, texpr) in methods {
                    texpr.collect_validation_issues(issues);
                }
            }
            TItem::EffectDecl { operations, .. } => {
                for (_, ty) in operations {
                    issues.extend(ty.validation_issues());
                }
            }
            TItem::Module { items, .. } => {
                for item in items {
                    item.collect_validation_issues(issues);
                }
            }
        }
    }
}

impl TDecl {
    fn collect_validation_issues(&self, issues: &mut Vec<String>) {
        match self {
            TDecl::Let { pattern, scheme, value } => {
                pattern.collect_validation_issues(issues);
                issues.extend(scheme.ty.validation_issues());
                value.collect_validation_issues(issues);
            }
            TDecl::LetRec { bindings } => {
                for binding in bindings {
                    issues.extend(binding.scheme.ty.validation_issues());
                    for param in &binding.params {
                        param.collect_validation_issues(issues);
                    }
                    binding.body.collect_validation_issues(issues);
                }
            }
        }
    }
}

impl TExpr {
    /// Validate this expression and all sub-expressions.
    pub fn collect_validation_issues(&self, issues: &mut Vec<String>) {
        // Check this expression's type
        issues.extend(self.ty.validation_issues());

        // Recursively check sub-expressions
        match &self.kind {
            TExprKind::Lit(_) | TExprKind::Hole | TExprKind::NewChannel => {}
            TExprKind::Var { .. } => {}
            TExprKind::Lambda { params, body } => {
                for p in params {
                    p.collect_validation_issues(issues);
                }
                body.collect_validation_issues(issues);
            }
            TExprKind::App { func, arg } => {
                func.collect_validation_issues(issues);
                arg.collect_validation_issues(issues);
            }
            TExprKind::Let { pattern, scheme, value, body } => {
                pattern.collect_validation_issues(issues);
                issues.extend(scheme.ty.validation_issues());
                value.collect_validation_issues(issues);
                if let Some(b) = body {
                    b.collect_validation_issues(issues);
                }
            }
            TExprKind::LetRec { bindings, body } => {
                for b in bindings {
                    issues.extend(b.scheme.ty.validation_issues());
                    for p in &b.params {
                        p.collect_validation_issues(issues);
                    }
                    b.body.collect_validation_issues(issues);
                }
                if let Some(b) = body {
                    b.collect_validation_issues(issues);
                }
            }
            TExprKind::If { cond, then_branch, else_branch } => {
                cond.collect_validation_issues(issues);
                then_branch.collect_validation_issues(issues);
                else_branch.collect_validation_issues(issues);
            }
            TExprKind::Match { scrutinee, arms } => {
                scrutinee.collect_validation_issues(issues);
                for arm in arms {
                    arm.pattern.collect_validation_issues(issues);
                    if let Some(g) = &arm.guard {
                        g.collect_validation_issues(issues);
                    }
                    arm.body.collect_validation_issues(issues);
                }
            }
            TExprKind::Tuple(exprs) | TExprKind::List(exprs) => {
                for e in exprs {
                    e.collect_validation_issues(issues);
                }
            }
            TExprKind::Constructor { args, .. } => {
                for a in args {
                    a.collect_validation_issues(issues);
                }
            }
            TExprKind::BinOp { left, right, .. } => {
                left.collect_validation_issues(issues);
                right.collect_validation_issues(issues);
            }
            TExprKind::UnaryOp { operand, .. } => {
                operand.collect_validation_issues(issues);
            }
            TExprKind::Seq { first, second } => {
                first.collect_validation_issues(issues);
                second.collect_validation_issues(issues);
            }
            TExprKind::Spawn(e) | TExprKind::ChanRecv(e) => {
                e.collect_validation_issues(issues);
            }
            TExprKind::ChanSend { channel, value } => {
                channel.collect_validation_issues(issues);
                value.collect_validation_issues(issues);
            }
            TExprKind::Select { arms } => {
                for arm in arms {
                    arm.channel.collect_validation_issues(issues);
                    arm.pattern.collect_validation_issues(issues);
                    arm.body.collect_validation_issues(issues);
                }
            }
            TExprKind::Perform { args, .. } => {
                for a in args {
                    a.collect_validation_issues(issues);
                }
            }
            TExprKind::Handle { body, return_clause, handlers } => {
                body.collect_validation_issues(issues);
                return_clause.pattern.collect_validation_issues(issues);
                return_clause.body.collect_validation_issues(issues);
                for h in handlers {
                    for p in &h.params {
                        p.collect_validation_issues(issues);
                    }
                    h.body.collect_validation_issues(issues);
                }
            }
            TExprKind::Record { fields, .. } => {
                for (_, e) in fields {
                    e.collect_validation_issues(issues);
                }
            }
            TExprKind::FieldAccess { record, .. } => {
                record.collect_validation_issues(issues);
            }
            TExprKind::RecordUpdate { base, updates } => {
                base.collect_validation_issues(issues);
                for (_, e) in updates {
                    e.collect_validation_issues(issues);
                }
            }
        }
    }
}

impl TPattern {
    fn collect_validation_issues(&self, issues: &mut Vec<String>) {
        issues.extend(self.ty.validation_issues());
        match &self.kind {
            TPatternKind::Var(_) | TPatternKind::Wildcard | TPatternKind::Lit(_) => {}
            TPatternKind::Constructor { args, .. } => {
                for a in args {
                    a.collect_validation_issues(issues);
                }
            }
            TPatternKind::Tuple(pats) | TPatternKind::List(pats) => {
                for p in pats {
                    p.collect_validation_issues(issues);
                }
            }
            TPatternKind::Cons { head, tail } => {
                head.collect_validation_issues(issues);
                tail.collect_validation_issues(issues);
            }
            TPatternKind::Record { fields, .. } => {
                for (_, opt_pat) in fields {
                    if let Some(p) = opt_pat {
                        p.collect_validation_issues(issues);
                    }
                }
            }
        }
    }
}
