-- =============================================================================
-- Recursive Shift Issue: Minimal Failing Cases
-- =============================================================================
--
-- This file documents the core answer-type limitation in Gneiss.
-- When a recursive function uses `shift` (directly or through operators like <|>),
-- the answer type becomes self-referential, triggering an infinite type error.

type ParseResult a =
    | Parsed a (List Char)
    | ParseFail String

let run_parser parser input =
    let k = reset (
        let result = parser () in
        fun remaining -> Parsed result remaining
    ) in
    k input

let (<|>) p1 p2 =
    fun () ->
      shift (fun k ->
        fun input ->
            match run_parser p1 input with
            | Parsed v rest -> k v rest
            | ParseFail _ -> run_parser p2 input
            end
    )

-- =============================================================================
-- WORKING CASES (no recursion through shift)
-- =============================================================================

-- Simple recursion without shift: WORKS
let rec countdown n =
    if n <= 0 then 0
    else countdown (n - 1)

-- Non-recursive use of <|>: WORKS
let simple_alt () = (fun () -> 1) <|> (fun () -> 2)

-- Mutual recursion without shift: WORKS
let rec ping () = pong ()
and pong () = 42

-- =============================================================================
-- FAILING CASE: Recursive function using shift
-- =============================================================================

-- This is the minimal failing pattern:
-- A recursive function that uses (<|>) (which uses shift) to call itself.
--
-- UNCOMMENT TO SEE THE ERROR:
-- let rec single () =
--     (fun () -> single ()) <|> (fun () -> 42)
--
-- Error: "I detected an infinite type. The type `() -> a` refers to itself"

-- =============================================================================
-- WHY IT FAILS
-- =============================================================================
--
-- The type of `(<|>)` with answer types is approximately:
--   (<|>) : (unit/α → a/β) → (unit/γ → a/δ) → (unit/... → a/...)
--
-- When `single` calls itself through (<|>):
--   single : unit/X → T/Y   for some X, Y, T
--
-- The recursive call `(fun () -> single ())` inside shift means:
--   - The answer type of `single` appears in the answer type of the shift body
--   - This creates: X = ... X ... (self-reference)
--   - Triggers occurs check → infinite type
--
-- =============================================================================
-- SOLUTION: Explicit Answer-Type Annotations
-- =============================================================================
--
-- To break the cycle, we need to annotate the answer type explicitly:
--
-- val single : unit/α → Int/β   -- explicit annotation
-- let rec single () =
--     (fun () -> single ()) <|> (fun () -> 42)
--
-- This requires:
-- 1. Parsing answer-type syntax in type signatures: σ/α → τ/β
-- 2. Using the annotation to constrain inference instead of inferring
