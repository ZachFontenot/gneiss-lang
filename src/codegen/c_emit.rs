//! C Code Generation
//!
//! Emits C source code from Core IR. The generated code uses a simple
//! runtime library for value representation and memory management.
//!
//! ## Value Representation
//!
//! All values are represented as `gn_value` (uint64_t):
//! - Integers: tagged with low bit = 1 (immediate, unboxed)
//! - Heap objects: pointers (aligned, low bit = 0)
//!
//! ## Generated Code Structure
//!
//! ```c
//! #include "gn_runtime.h"
//!
//! // Forward declarations
//! static gn_value fn_foo(gn_value arg0, gn_value arg1);
//!
//! // Function definitions
//! static gn_value fn_foo(gn_value arg0, gn_value arg1) {
//!     ...
//! }
//!
//! // Main entry
//! int main(int argc, char** argv) {
//!     gn_init(argc, argv);
//!     gn_value result = ...;
//!     gn_shutdown();
//!     return 0;
//! }
//! ```

use std::collections::HashMap;
use std::fmt::Write;

use super::core_ir::{
    Alt, Atom, CoreExpr, CoreLit, CoreProgram, FunDef, PrimOp, RecBinding, VarId,
};

// ============================================================================
// Code Emitter
// ============================================================================

/// C code emitter context
pub struct CEmitter {
    /// Output buffer
    output: String,
    /// Current indentation level
    indent: usize,
    /// Map from VarId to C variable name
    var_names: HashMap<VarId, String>,
    /// Counter for generating unique names
    name_counter: u32,
    /// Forward declarations buffer
    forward_decls: String,
    /// Top-level function definitions
    function_defs: String,
    /// Generated functions (from LetRec during main emission)
    generated_funcs: String,
}

impl CEmitter {
    pub fn new() -> Self {
        CEmitter {
            output: String::new(),
            indent: 0,
            var_names: HashMap::new(),
            name_counter: 0,
            forward_decls: String::new(),
            function_defs: String::new(),
            generated_funcs: String::new(),
        }
    }

    /// Emit a complete C program from Core IR
    pub fn emit_program(&mut self, program: &CoreProgram) -> String {
        // Header
        self.output.push_str("// Generated by gneic - Gneiss Compiler\n");
        self.output.push_str("// DO NOT EDIT\n\n");
        self.output.push_str("#include \"gn_runtime.h\"\n\n");

        // Emit forward declarations for all functions
        for fun in &program.functions {
            self.emit_forward_decl(fun);
        }

        if !self.forward_decls.is_empty() {
            self.output.push_str("// Forward declarations\n");
            self.output.push_str(&self.forward_decls);
            self.output.push('\n');
        }

        // Emit function definitions
        for fun in &program.functions {
            self.emit_function(fun);
        }

        if !self.function_defs.is_empty() {
            self.output.push_str("// Function definitions\n");
            self.output.push_str(&self.function_defs);
        }

        // Emit main
        self.emit_main(&program.main);

        self.output.clone()
    }

    /// Emit forward declaration for a function
    fn emit_forward_decl(&mut self, fun: &FunDef) {
        let params: Vec<String> = fun
            .params
            .iter()
            .enumerate()
            .map(|(i, _)| format!("gn_value arg{}", i))
            .collect();

        let params_str = if params.is_empty() {
            "void".to_string()
        } else {
            params.join(", ")
        };

        writeln!(
            self.forward_decls,
            "static gn_value fn_{}({});",
            mangle_name(&fun.name),
            params_str
        )
        .unwrap();
    }

    /// Emit a function definition
    fn emit_function(&mut self, fun: &FunDef) {
        // Clear var names for this function
        self.var_names.clear();

        // Bind parameters
        for (i, (param, hint)) in fun.params.iter().zip(fun.param_hints.iter()).enumerate() {
            let name = format!("arg{}", i);
            self.var_names.insert(*param, name.clone());
        }

        let params: Vec<String> = fun
            .params
            .iter()
            .enumerate()
            .map(|(i, _)| format!("gn_value arg{}", i))
            .collect();

        let params_str = if params.is_empty() {
            "void".to_string()
        } else {
            params.join(", ")
        };

        writeln!(
            self.function_defs,
            "static gn_value fn_{}({}) {{",
            mangle_name(&fun.name),
            params_str
        )
        .unwrap();

        self.indent = 1;
        let body = self.emit_expr(&fun.body);
        writeln!(self.function_defs, "{}return {};", self.pad(), body).unwrap();
        writeln!(self.function_defs, "}}\n").unwrap();
    }

    /// Emit main function
    fn emit_main(&mut self, main_expr: &Option<CoreExpr>) {
        if let Some(expr) = main_expr {
            self.indent = 1;
            self.var_names.clear();

            // Temporarily use function_defs as statement buffer for main
            let saved_defs = std::mem::take(&mut self.function_defs);
            let saved_gen_funcs = std::mem::take(&mut self.generated_funcs);

            let result = self.emit_expr(expr);

            // Collect the statements emitted during expr lowering
            let main_stmts = std::mem::replace(&mut self.function_defs, saved_defs);

            // Collect any generated functions (from LetRec)
            let gen_funcs = std::mem::replace(&mut self.generated_funcs, saved_gen_funcs);

            // Emit generated functions before main
            if !gen_funcs.is_empty() {
                self.output.push_str("// Generated functions\n");
                self.output.push_str(&gen_funcs);
            }

            // Emit main function
            self.output.push_str("// Main entry point\n");
            self.output
                .push_str("int main(int argc, char** argv) {\n");
            self.output.push_str("    gn_init(argc, argv);\n");
            self.output.push_str(&main_stmts);
            writeln!(self.output, "    gn_value result = {};", result).unwrap();
            self.output.push_str("    gn_print(result);\n");
            self.output.push_str("    gn_println();\n");
            self.output.push_str("    gn_shutdown();\n");
            self.output.push_str("    return 0;\n");
            self.output.push_str("}\n");
        } else {
            self.output.push_str("// Main entry point\n");
            self.output
                .push_str("int main(int argc, char** argv) {\n");
            self.output.push_str("    gn_init(argc, argv);\n");
            self.output.push_str("    gn_shutdown();\n");
            self.output.push_str("    return 0;\n");
            self.output.push_str("}\n");
        }
    }

    /// Emit an expression, returning the C expression string
    fn emit_expr(&mut self, expr: &CoreExpr) -> String {
        match expr {
            CoreExpr::Var(var) => self.get_var_name(*var),

            CoreExpr::Lit(lit) => self.emit_literal(lit),

            CoreExpr::Let {
                name,
                name_hint,
                value,
                body,
            } => {
                let var_name = self.fresh_var(name_hint.as_deref());
                self.var_names.insert(*name, var_name.clone());

                let value_expr = self.emit_atom(value);
                writeln!(
                    self.function_defs,
                    "{}gn_value {} = {};",
                    self.pad(),
                    var_name,
                    value_expr
                )
                .unwrap();

                self.emit_expr(body)
            }

            CoreExpr::LetExpr {
                name,
                name_hint,
                value,
                body,
            } => {
                let var_name = self.fresh_var(name_hint.as_deref());
                self.var_names.insert(*name, var_name.clone());

                let value_expr = self.emit_expr(value);
                writeln!(
                    self.function_defs,
                    "{}gn_value {} = {};",
                    self.pad(),
                    var_name,
                    value_expr
                )
                .unwrap();

                self.emit_expr(body)
            }

            CoreExpr::App { func, args } => {
                let func_name = self.get_var_name(*func);
                let args_str: Vec<String> = args.iter().map(|a| self.get_var_name(*a)).collect();

                // Check if this is a known function call
                if func_name.starts_with("fn_") {
                    format!("{}({})", func_name, args_str.join(", "))
                } else {
                    // Closure call
                    format!("gn_apply({}, {})", func_name, args_str.join(", "))
                }
            }

            CoreExpr::TailApp { func, args } => {
                // For now, emit as regular call (TCO optimization comes later)
                let func_name = self.get_var_name(*func);
                let args_str: Vec<String> = args.iter().map(|a| self.get_var_name(*a)).collect();
                format!("{}({})", func_name, args_str.join(", "))
            }

            CoreExpr::Alloc {
                tag,
                ctor_name,
                fields,
                ..
            } => {
                let fields_str: Vec<String> =
                    fields.iter().map(|f| self.get_var_name(*f)).collect();
                let name = ctor_name
                    .as_ref()
                    .map(|s| s.as_str())
                    .unwrap_or("anon");

                if fields.is_empty() {
                    // Nullary constructor - can be a singleton
                    format!("GN_CTOR({}, 0) /* {} */", tag, name)
                } else {
                    format!(
                        "gn_alloc({}, {}, (gn_value[]){{{}}})",
                        tag,
                        fields.len(),
                        fields_str.join(", ")
                    )
                }
            }

            CoreExpr::Case {
                scrutinee,
                alts,
                default,
            } => self.emit_case(*scrutinee, alts, default.as_deref()),

            CoreExpr::If {
                cond,
                then_branch,
                else_branch,
            } => {
                let result_var = self.fresh_var(Some("if_result"));
                let cond_name = self.get_var_name(*cond);

                writeln!(self.function_defs, "{}gn_value {};", self.pad(), result_var).unwrap();
                writeln!(
                    self.function_defs,
                    "{}if (GN_IS_TRUE({})) {{",
                    self.pad(),
                    cond_name
                )
                .unwrap();

                self.indent += 1;
                let then_expr = self.emit_expr(then_branch);
                writeln!(
                    self.function_defs,
                    "{}{} = {};",
                    self.pad(),
                    result_var,
                    then_expr
                )
                .unwrap();
                self.indent -= 1;

                writeln!(self.function_defs, "{}}} else {{", self.pad()).unwrap();

                self.indent += 1;
                let else_expr = self.emit_expr(else_branch);
                writeln!(
                    self.function_defs,
                    "{}{} = {};",
                    self.pad(),
                    result_var,
                    else_expr
                )
                .unwrap();
                self.indent -= 1;

                writeln!(self.function_defs, "{}}}", self.pad()).unwrap();

                result_var
            }

            CoreExpr::Lam {
                params,
                param_hints,
                body,
            } => {
                // Lambda - needs to create a closure
                // For now, just emit a placeholder (lambda lifting would fix this)
                format!("GN_UNIT /* lambda not yet supported */")
            }

            CoreExpr::LetRec {
                name,
                name_hint,
                params,
                param_hints: _,
                func_body,
                body,
            } => {
                // Emit recursive function as top-level C function
                let func_name = format!(
                    "fn_{}",
                    mangle_name(name_hint.as_deref().unwrap_or("anon"))
                );
                self.var_names.insert(*name, func_name.clone());

                // Build parameter list
                let param_strs: Vec<String> = params
                    .iter()
                    .enumerate()
                    .map(|(i, _)| format!("gn_value arg{}", i))
                    .collect();
                let params_str = if param_strs.is_empty() {
                    "void".to_string()
                } else {
                    param_strs.join(", ")
                };

                // Emit forward declaration
                writeln!(
                    self.forward_decls,
                    "static gn_value {}({});",
                    func_name, params_str
                )
                .unwrap();

                // Save current state
                let saved_var_names = self.var_names.clone();
                let saved_counter = self.name_counter;
                let saved_indent = self.indent;

                // Clear var_names for the function and set up parameters
                self.var_names.clear();
                self.var_names.insert(*name, func_name.clone()); // Self-reference
                for (i, param) in params.iter().enumerate() {
                    let arg_name = format!("arg{}", i);
                    self.var_names.insert(*param, arg_name);
                }

                // Emit function body to a separate buffer
                let mut func_body_stmts = String::new();
                std::mem::swap(&mut func_body_stmts, &mut self.function_defs);
                self.indent = 1;

                let result = self.emit_expr(func_body);

                std::mem::swap(&mut func_body_stmts, &mut self.function_defs);

                // Emit complete function definition to generated_funcs buffer
                writeln!(
                    self.generated_funcs,
                    "static gn_value {}({}) {{",
                    func_name, params_str
                )
                .unwrap();
                self.generated_funcs.push_str(&func_body_stmts);
                writeln!(self.generated_funcs, "    return {};", result).unwrap();
                writeln!(self.generated_funcs, "}}\n").unwrap();

                // Restore state
                self.var_names = saved_var_names;
                self.var_names.insert(*name, func_name); // Keep the function binding
                self.name_counter = saved_counter;
                self.indent = saved_indent;

                // Continue with body
                self.emit_expr(body)
            }

            CoreExpr::LetRecMutual { bindings, body } => {
                // TODO: mutual recursion support
                self.emit_expr(body)
            }

            CoreExpr::Seq { first, second } => {
                let first_expr = self.emit_expr(first);
                writeln!(self.function_defs, "{}{};", self.pad(), first_expr).unwrap();
                self.emit_expr(second)
            }

            CoreExpr::PrimOp { op, args } => self.emit_primop(op, args),

            CoreExpr::Return(var) => self.get_var_name(*var),

            CoreExpr::ExternCall { name, args } => {
                let args_str: Vec<String> = args.iter().map(|a| self.get_var_name(*a)).collect();
                format!("{}({})", name, args_str.join(", "))
            }

            CoreExpr::Error(msg) => {
                format!("gn_panic(\"{}\")", escape_string(msg))
            }

            CoreExpr::Perform { effect_name, op_name, args, .. } => {
                let effect = effect_name.as_ref().map(|s| s.as_str()).unwrap_or("?");
                let op = op_name.as_ref().map(|s| s.as_str()).unwrap_or("?");
                format!("gn_panic(\"perform {}.{} not implemented\")", effect, op)
            }

            CoreExpr::Handle { body, handler } => {
                // Effects not yet implemented
                self.emit_expr(body)
            }
        }
    }

    /// Emit an atom (simple expression)
    fn emit_atom(&mut self, atom: &Atom) -> String {
        match atom {
            Atom::Var(var) => self.get_var_name(*var),
            Atom::Lit(lit) => self.emit_literal(lit),
            Atom::Alloc {
                tag,
                ctor_name,
                fields,
                ..
            } => {
                let fields_str: Vec<String> =
                    fields.iter().map(|f| self.get_var_name(*f)).collect();
                let name = ctor_name.as_ref().map(|s| s.as_str()).unwrap_or("anon");
                if fields.is_empty() {
                    format!("GN_CTOR({}, 0) /* {} */", tag, name)
                } else {
                    format!(
                        "gn_alloc({}, {}, (gn_value[]){{{}}})",
                        tag,
                        fields.len(),
                        fields_str.join(", ")
                    )
                }
            }
            Atom::PrimOp { op, args } => self.emit_primop(op, args),
            Atom::Lam { .. } => "GN_UNIT /* lambda */".to_string(),
            Atom::App { func, args } => {
                let func_name = self.get_var_name(*func);
                let args_str: Vec<String> = args.iter().map(|a| self.get_var_name(*a)).collect();
                format!("gn_apply({}, {})", func_name, args_str.join(", "))
            }
        }
    }

    /// Emit a case expression
    fn emit_case(&mut self, scrutinee: VarId, alts: &[Alt], default: Option<&CoreExpr>) -> String {
        let result_var = self.fresh_var(Some("case_result"));
        let scrut_name = self.get_var_name(scrutinee);

        writeln!(self.function_defs, "{}gn_value {};", self.pad(), result_var).unwrap();
        writeln!(
            self.function_defs,
            "{}switch (GN_TAG({})) {{",
            self.pad(),
            scrut_name
        )
        .unwrap();

        for alt in alts {
            let tag_name = alt.tag_name.as_ref().map(|s| s.as_str()).unwrap_or("?");
            writeln!(
                self.function_defs,
                "{}case {}: /* {} */ {{",
                self.pad(),
                alt.tag,
                tag_name
            )
            .unwrap();

            self.indent += 1;

            // Bind the fields
            for (i, (binder, hint)) in alt.binders.iter().zip(alt.binder_hints.iter()).enumerate() {
                let var_name = self.fresh_var(hint.as_deref());
                self.var_names.insert(*binder, var_name.clone());
                writeln!(
                    self.function_defs,
                    "{}gn_value {} = GN_FIELD({}, {});",
                    self.pad(),
                    var_name,
                    scrut_name,
                    i
                )
                .unwrap();
            }

            let body_expr = self.emit_expr(&alt.body);
            writeln!(
                self.function_defs,
                "{}{} = {};",
                self.pad(),
                result_var,
                body_expr
            )
            .unwrap();
            writeln!(self.function_defs, "{}break;", self.pad()).unwrap();

            self.indent -= 1;
            writeln!(self.function_defs, "{}}}", self.pad()).unwrap();
        }

        // Default case
        writeln!(self.function_defs, "{}default: {{", self.pad()).unwrap();
        self.indent += 1;
        if let Some(def) = default {
            let def_expr = self.emit_expr(def);
            writeln!(
                self.function_defs,
                "{}{} = {};",
                self.pad(),
                result_var,
                def_expr
            )
            .unwrap();
        } else {
            writeln!(
                self.function_defs,
                "{}gn_panic(\"non-exhaustive match\");",
                self.pad()
            )
            .unwrap();
            writeln!(
                self.function_defs,
                "{}{} = GN_UNIT;",
                self.pad(),
                result_var
            )
            .unwrap();
        }
        writeln!(self.function_defs, "{}break;", self.pad()).unwrap();
        self.indent -= 1;
        writeln!(self.function_defs, "{}}}", self.pad()).unwrap();

        writeln!(self.function_defs, "{}}}", self.pad()).unwrap();

        result_var
    }

    /// Emit a primitive operation
    fn emit_primop(&self, op: &PrimOp, args: &[VarId]) -> String {
        let args_str: Vec<String> = args.iter().map(|a| self.get_var_name(*a)).collect();

        match op {
            // Arithmetic (Int)
            PrimOp::IntAdd => format!("GN_INT_ADD({}, {})", args_str[0], args_str[1]),
            PrimOp::IntSub => format!("GN_INT_SUB({}, {})", args_str[0], args_str[1]),
            PrimOp::IntMul => format!("GN_INT_MUL({}, {})", args_str[0], args_str[1]),
            PrimOp::IntDiv => format!("GN_INT_DIV({}, {})", args_str[0], args_str[1]),
            PrimOp::IntMod => format!("GN_INT_MOD({}, {})", args_str[0], args_str[1]),
            PrimOp::IntNeg => format!("GN_INT_NEG({})", args_str[0]),

            // Arithmetic (Float)
            PrimOp::FloatAdd => format!("gn_float_add({}, {})", args_str[0], args_str[1]),
            PrimOp::FloatSub => format!("gn_float_sub({}, {})", args_str[0], args_str[1]),
            PrimOp::FloatMul => format!("gn_float_mul({}, {})", args_str[0], args_str[1]),
            PrimOp::FloatDiv => format!("gn_float_div({}, {})", args_str[0], args_str[1]),
            PrimOp::FloatNeg => format!("gn_float_neg({})", args_str[0]),

            // Comparison (Int)
            PrimOp::IntEq => format!("GN_INT_EQ({}, {})", args_str[0], args_str[1]),
            PrimOp::IntNe => format!("GN_INT_NE({}, {})", args_str[0], args_str[1]),
            PrimOp::IntLt => format!("GN_INT_LT({}, {})", args_str[0], args_str[1]),
            PrimOp::IntLe => format!("GN_INT_LE({}, {})", args_str[0], args_str[1]),
            PrimOp::IntGt => format!("GN_INT_GT({}, {})", args_str[0], args_str[1]),
            PrimOp::IntGe => format!("GN_INT_GE({}, {})", args_str[0], args_str[1]),

            // Comparison (Float)
            PrimOp::FloatEq => format!("gn_float_eq({}, {})", args_str[0], args_str[1]),
            PrimOp::FloatNe => format!("gn_float_ne({}, {})", args_str[0], args_str[1]),
            PrimOp::FloatLt => format!("gn_float_lt({}, {})", args_str[0], args_str[1]),
            PrimOp::FloatLe => format!("gn_float_le({}, {})", args_str[0], args_str[1]),
            PrimOp::FloatGt => format!("gn_float_gt({}, {})", args_str[0], args_str[1]),
            PrimOp::FloatGe => format!("gn_float_ge({}, {})", args_str[0], args_str[1]),

            // Boolean
            PrimOp::BoolAnd => format!("GN_BOOL_AND({}, {})", args_str[0], args_str[1]),
            PrimOp::BoolOr => format!("GN_BOOL_OR({}, {})", args_str[0], args_str[1]),
            PrimOp::BoolNot => format!("GN_BOOL_NOT({})", args_str[0]),

            // String
            PrimOp::StringConcat => format!("gn_string_concat({}, {})", args_str[0], args_str[1]),
            PrimOp::StringLength => format!("gn_string_length({})", args_str[0]),
            PrimOp::StringEq => format!("gn_string_eq({}, {})", args_str[0], args_str[1]),

            // Conversion
            PrimOp::IntToFloat => format!("gn_int_to_float({})", args_str[0]),
            PrimOp::FloatToInt => format!("gn_float_to_int({})", args_str[0]),
            PrimOp::IntToString => format!("gn_int_to_string({})", args_str[0]),
            PrimOp::FloatToString => format!("gn_float_to_string({})", args_str[0]),
            PrimOp::CharToInt => format!("GN_CHAR_TO_INT({})", args_str[0]),
            PrimOp::IntToChar => format!("GN_INT_TO_CHAR({})", args_str[0]),

            // Tuple/record
            PrimOp::TupleGet(n) => format!("GN_FIELD({}, {})", args_str[0], n),

            // List
            PrimOp::ListCons => format!("gn_list_cons({}, {})", args_str[0], args_str[1]),
            PrimOp::ListHead => format!("gn_list_head({})", args_str[0]),
            PrimOp::ListTail => format!("gn_list_tail({})", args_str[0]),
            PrimOp::ListIsEmpty => format!("gn_list_is_empty({})", args_str[0]),
        }
    }

    /// Emit a literal
    fn emit_literal(&self, lit: &CoreLit) -> String {
        match lit {
            CoreLit::Int(n) => format!("GN_INT({})", n),
            CoreLit::Float(f) => format!("gn_float({})", f),
            CoreLit::String(s) => format!("gn_string(\"{}\")", escape_string(s)),
            CoreLit::Char(c) => format!("GN_CHAR({})", *c as u32),
            CoreLit::Bool(true) => "GN_TRUE".to_string(),
            CoreLit::Bool(false) => "GN_FALSE".to_string(),
            CoreLit::Unit => "GN_UNIT".to_string(),
        }
    }

    /// Get the C variable name for a VarId
    fn get_var_name(&self, var: VarId) -> String {
        self.var_names
            .get(&var)
            .cloned()
            .unwrap_or_else(|| format!("v{}", var.0))
    }

    /// Generate a fresh variable name
    fn fresh_var(&mut self, hint: Option<&str>) -> String {
        let name = if let Some(h) = hint {
            format!("{}_{}", mangle_name(h), self.name_counter)
        } else {
            format!("tmp_{}", self.name_counter)
        };
        self.name_counter += 1;
        name
    }

    /// Get indentation padding
    fn pad(&self) -> String {
        "    ".repeat(self.indent)
    }
}

impl Default for CEmitter {
    fn default() -> Self {
        Self::new()
    }
}

// ============================================================================
// Helpers
// ============================================================================

/// Mangle a name to be a valid C identifier
fn mangle_name(name: &str) -> String {
    let mut result = String::new();
    for c in name.chars() {
        match c {
            'a'..='z' | 'A'..='Z' | '0'..='9' => result.push(c),
            '_' => result.push('_'),
            '\'' => result.push_str("_prime"),
            _ => result.push_str(&format!("_u{:04x}_", c as u32)),
        }
    }
    result
}

/// Escape a string for C
fn escape_string(s: &str) -> String {
    let mut result = String::new();
    for c in s.chars() {
        match c {
            '"' => result.push_str("\\\""),
            '\\' => result.push_str("\\\\"),
            '\n' => result.push_str("\\n"),
            '\r' => result.push_str("\\r"),
            '\t' => result.push_str("\\t"),
            c if c.is_ascii_graphic() || c == ' ' => result.push(c),
            c => result.push_str(&format!("\\x{:02x}", c as u32)),
        }
    }
    result
}

// ============================================================================
// Public API
// ============================================================================

/// Compile a CoreProgram to C source code
pub fn emit_c(program: &CoreProgram) -> String {
    let mut emitter = CEmitter::new();
    emitter.emit_program(program)
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use crate::codegen::lower::lower_program;
    use crate::{Lexer, Parser};

    fn compile_to_c(source: &str) -> Result<String, String> {
        let tokens = Lexer::new(source)
            .tokenize()
            .map_err(|e| format!("{:?}", e))?;
        let program = Parser::new(tokens)
            .parse_program()
            .map_err(|e| format!("{:?}", e))?;
        let core = lower_program(&program).map_err(|e| e.join("\n"))?;
        Ok(emit_c(&core))
    }

    #[test]
    fn test_emit_literal() {
        let c_code = compile_to_c("42").unwrap();
        assert!(c_code.contains("GN_INT(42)"));
    }

    #[test]
    fn test_emit_binop() {
        let c_code = compile_to_c("1 + 2").unwrap();
        assert!(c_code.contains("GN_INT_ADD"));
    }

    #[test]
    fn test_emit_if() {
        let c_code = compile_to_c("if true then 1 else 2").unwrap();
        assert!(c_code.contains("GN_IS_TRUE"));
    }

    #[test]
    fn test_emit_function() {
        let c_code = compile_to_c("let rec f x = x + 1 in f 5").unwrap();
        // Should have some function definition or call
        assert!(c_code.contains("main"));
    }
}
