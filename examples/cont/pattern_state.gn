-- =============================================================================
-- Pattern: State (get/put)
-- =============================================================================
--
-- The state pattern threads mutable state through a computation without 
-- explicit parameter passing. `get` retrieves the current state, `put` 
-- updates it. This is similar to the State monad but with direct style.
--
-- Key insight: The continuation represents "the rest of the computation
-- that needs state". We capture it and pass the state explicitly.

-- Type for state computation results
-- The computation returns a value AND the final state
type StateResult s a = StateResult a s

-- get: retrieve current state (state -> (state, state))
let get () =
    shift (fun k ->
        -- k expects a value and returns StateResult
        -- We need to thread the state: receive s, give s to k, k continues with s
        fun s -> 
            let (StateResult result final_state) = k s s in
            StateResult result final_state
    )

-- put: update the state (state -> ((), new_state))
let put new_state =
    shift (fun k ->
        -- Ignore the input state, continue with new_state
        fun _old_state ->
            k () new_state
    )

-- modify: update state with a function
let modify f =
    let s = get () in
    put (f s)

-- run_state: execute a stateful computation with initial state
let run_state computation initial_state =
    let k = reset (
        let result = computation () in
        -- Final continuation: just wrap the result
        fun s -> StateResult result s
    ) in
    k initial_state

-- =============================================================================
-- Example 1: Simple counter
-- =============================================================================

let counter_example () =
    run_state (fun () ->
        let x = get () in      -- x = 0
        put (x + 1);           -- state = 1
        let y = get () in      -- y = 1
        put (y + 10);          -- state = 11
        let z = get () in      -- z = 11
        (x, y, z)              -- result = (0, 1, 11)
    ) 0

-- =============================================================================
-- Example 2: Accumulator pattern
-- =============================================================================

let sum_with_state xs =
    run_state (fun () ->
        let rec loop remaining =
            match remaining with
            | [] -> get ()
            | x :: rest ->
                modify (fun acc -> acc + x);
                loop rest
        in
        loop xs
    ) 0

-- =============================================================================
-- Example 3: State machine - simple tokenizer state
-- =============================================================================

type TokenizerState =
    | Ready
    | InNumber
    | InWord

let tokenizer_example input =
    run_state (fun () ->
        let rec process chars tokens =
            match chars with
            | [] -> 
                -- Flush any pending state
                let final_state = get () in
                tokens
            | c :: rest ->
                let current = get () in
                if is_digit c then (
                    match current with
                    | Ready -> put InNumber; process rest tokens
                    | InNumber -> process rest tokens
                    | InWord -> put InNumber; process rest tokens
                )
                else if is_alpha c then (
                    match current with
                    | Ready -> put InWord; process rest tokens
                    | InNumber -> put InWord; process rest tokens
                    | InWord -> process rest tokens
                )
                else (
                    put Ready;
                    process rest tokens
                )
        in
        process (chars input) []
    ) Ready

-- Helpers (assuming these exist or stub them)
let is_digit c = c >= '0' && c <= '9'
let is_alpha c = (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')
let chars s = [] -- stub: would convert string to char list

-- =============================================================================
-- Example 4: Combining state with other effects
-- =============================================================================
-- Count how many times we "yield" while generating values

let counted_yield x =
    modify (fun count -> count + 1);
    shift (fun k -> x :: k ())

let counted_generator () =
    run_state (fun () ->
        reset (
            counted_yield 10;
            counted_yield 20;
            counted_yield 30;
            []
        )
    ) 0

-- =============================================================================
-- Example 5: Fresh name generation
-- =============================================================================

let fresh prefix =
    let n = get () in
    put (n + 1);
    prefix ^ "_" ^ int_to_string n

let generate_names () =
    run_state (fun () ->
        let a = fresh "x" in    -- "x_0"
        let b = fresh "x" in    -- "x_1"
        let c = fresh "temp" in -- "temp_2"
        let d = fresh "x" in    -- "x_3"
        [a, b, c, d]
    ) 0

let int_to_string n =
    -- stub: would convert int to string
    if n == 0 then "0"
    else if n == 1 then "1"
    else if n == 2 then "2"
    else if n == 3 then "3"
    else "?"

let main () =
    print "=== Counter Example ===";
    let (StateResult result final) = counter_example () in
    print result;  -- (0, 1, 11)
    print final;   -- 11
    
    print "=== Sum with State ===";
    let (StateResult sum _) = sum_with_state [1, 2, 3, 4, 5] in
    print sum;  -- 15
    
    print "=== Fresh Names ===";
    let (StateResult names _) = generate_names () in
    print names  -- ["x_0", "x_1", "temp_2", "x_3"]
